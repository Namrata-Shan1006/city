<style>
  body {
    margin: 0;
    font-family: Segoe UI, Arial;
    background: #e0f2fe; /* light blue background */
    color: #0f172a;      /* dark navy text for contrast */
  }

  header {
    padding: 30px;
    background: #2563eb; /* strong blue header */
    color: #f0f9ff;      /* very light text */
  }

  h1 {
    margin: 0;
    font-size: 32px;
    color: #f0f9ff; /* header title in light text */
  }

  p {
    line-height: 1.6;
    color: #0f172a; /* readable dark text */
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    padding: 30px;
  }

  .card {
    background: #93c5fd; /* medium light blue card */
    border-radius: 14px;
    padding: 20px;
    cursor: pointer;
    transition: .3s;
    color: #0f172a; /* dark text inside cards */
  }

  .card:hover {
    transform: scale(1.03);
    background: #60a5fa; /* brighter blue on hover */
  }

  .card span {
    font-size: 22px;
  }

  .modal {
    position: fixed;
    inset: 0;
    background: rgba(37, 99, 235, 0.85); /* semi-transparent blue overlay */
    display: none;
    align-items: center;
    justify-content: center;
  }

  .modal-content {
    background: #f0f9ff; /* very light blue modal background */
    width: 85%;
    max-height: 85%;
    overflow: auto;
    border-radius: 16px;
    padding: 30px;
    color: #0f172a; /* dark text inside modal */
  }

  .close {
    float: right;
    font-size: 22px;
    cursor: pointer;
    color: #2563eb; /* blue close button */
  }

  button {
    background: #2563eb; /* blue button */
    border: none;
    color: #f0f9ff; /* light text */
    padding: 10px 16px;
    border-radius: 8px;
    cursor: pointer;
    margin-top: 10px;
  }

  button:hover {
    background: #1e40af; /* darker blue hover */
  }

  pre {
    background: #e0f2fe; /* light blue code block */
    padding: 15px;
    border-radius: 10px;
    overflow: auto;
    display: none;
    white-space: pre-wrap;
    color: #0f172a;
  }

  h3 {
    margin-top: 25px;
    color: #2563eb; /* blue section headings */
  }
</style>
</head>
<body>
<header>
  <h1 style="margin:0; font-size:32px; color:white;">
    Anoosha Hokrani
  </h1>
    <p style="color:white; font-size:20px; margin-top:15px;">
    Smart City Systems & Infrastructure â€“ Project Bellasagaram
  </p>
</header><h2 style="color: #2563eb; font-size: 26px; text-align: center; margin-top: 40px;">
  ğŸ”· 10 Visionary Business Ideas for a Smart city ğŸ”·
</h2>

<div class="grid">
  <div class="card" onclick="openModal('waste')">â™»ï¸ Smart Waste Collection</div>
  <div class="card" onclick="openModal('parking')">ğŸ…¿ Smart Parking System</div>
  <div class="card" onclick="openModal('energy')">â˜€ Renewable Energy Grid</div>
  <div class="card" onclick="openModal('cargo')">ğŸ“¦ Port Cargo Scheduling</div>
  <div class="card" onclick="openModal('transport')">ğŸšŒ Public Transport Optimization</div>
  <div class="card" onclick="openModal('water')">ğŸ’§ Water Distribution System</div>
  <div class="card" onclick="openModal('emergency')">ğŸš¨ Emergency Dispatch System</div>
  <div class="card" onclick="openModal('housing')">ğŸ  Smart Housing Allocation</div>
  <div class="card" onclick="openModal('market')">ğŸ“Š Smart Market Analyzer</div>
  <div class="card" onclick="openModal('logistics')">ğŸšš Industrial Logistics</div>
</div>

<div class="modal" id="modal">
  <div class="modal-content">
    <span class="close" onclick="closeModal()">âœ–</span>
    <h2 id="title"></h2>
    <div id="desc"></div>
    <button onclick="toggleCode()">View Algorithm Code</button>
    <pre id="code"></pre>
  </div>
</div>

<script>
const data={
  waste: {
  title: 'Smart Waste Collection & Recycling Management',
  desc: `
    <h3>Problem Statement</h3>
    <p>Urban and marine waste collection is inefficient due to fixed routes, poor prioritization of hazardous waste, and lack of real-time recycling plant selection.</p>

    <h3>System Approach</h3>
    <p>The system registers waste sources using AVL Trees, prioritizes waste types via Max-Heaps, optimizes truck routes using Dijkstra and Bellmanâ€“Ford, and selects recycling plants with Min-Heaps.</p>

    <h3>Algorithms Used</h3>
    <p>AVL Tree, Max Heap, Min Heap, Dijkstra, Bellmanâ€“Ford, Floydâ€“Warshall, Merge Sort, KMP, Kruskal, Prim, Red-Black Tree</p>

    <h3>â™» Smart Waste Collection & Recycling System</h3>
    <ul>
      <li><b>Waste Registry:</b> AVL Tree â€“ O(log n) insert/search for city, port & marine waste nodes</li>
      <li><b>Waste Priority:</b> Max Heap â€“ medical & hazardous waste collected first</li>
      <li><b>Marine Alerts:</b> Sensor thresholds + Min Heap to prioritize aquatic pollution zones</li>
      <li><b>Route Optimization:</b> Dijkstra for shortest paths; Bellmanâ€“Ford for penalty costs; Floydâ€“Warshall for all-pairs routing</li>
      <li><b>Recycling Plant Choice:</b> Min Heap â€“ lowest cost, load & distance</li>
      <li><b>Industrial Logs:</b> Merge Sort â€“ stable daily waste & toxicity reports</li>
      <li><b>Factory Registry:</b> Red-Black Tree â€“ recycling output tracking</li>
      <li><b>Report Search:</b> KMP â€“ fast keyword detection in logs</li>
      <li><b>Truck Assignment:</b> Priority queue with constraints (capacity, battery, proximity)</li>
      <li><b>Marine Network:</b> Kruskal & Prim â€“ minimum-cost sea waste collection</li>
      <li><b>System Reports:</b> Sorted grouping by zone and material type</li>
    </ul>

    <p><b>SDGs:</b> SDG-11, SDG-12, SDG-14, SDG-6</p>
  `,
    code:`//#include <bits/stdc++.h>
using namespace std;

/* ===========================
**Â   CONFIG**
**Â   =========================== */**
const int MAX_NODES = 80;
const int MAX_REQUESTS = 1000;
const int MAX_TRUCKS = 80;
const int MAX_BOATS = 40;
const int MAX_FACTORIES = 80;
const int INF = 1000000000;

/* ===========================
**Â   ENUMS & NAMES**
**Â   =========================== */**
enum WasteType { W_HOUSEHOLD=0, W_COMMERCIAL=1, W_INDUSTRIAL=2, W_SEA_AQUATIC=3, W_HAZARDOUS=4 };
const char* WasteTypeName[] = {"Household","Commercial","Industrial","Sea/Aquatic","Hazardous"};

/* ===========================
**Â   DATA STRUCTS**
**Â   =========================== */**
struct Request {
**Â    int id;**
**Â    int node;           // location node**
**Â    WasteType type;**
**Â    int volume;         // liters**
**Â    int priority;       // computed priority (higher = more urgent)**
**Â    int timestamp;      // request creation time (simulated minutes)**
**Â    bool processed;**
**Â    bool assigned;      // assigned to vehicle**
**Â    int assignedVehicleId; // id of truck/boat**
};

struct VehicleCommon {
**Â    int id;**
**Â    int currentNode;**
**Â    int capacity;**
**Â    int load;           // liters loaded**
**Â    bool available;**
**Â    int speed;          // units (distance) per simulated minute**
**Â    int destNode;       // destination node if moving, -1 if idle**
**Â    int remainingDist;  // remaining distance units to destination**
**Â    int assignedRequestIdx; // index in requests array, or -1**
};

struct Truck {
**Â    VehicleCommon c;**
};

struct Boat {
**Â    VehicleCommon c;**
**Â    bool sea_enabled; // true for boats**
};

struct Factory {
**Â    int id;**
**Â    char name[64];**
**Â    int node;**
**Â    int capacityIn;**
**Â    int storedRaw;**
**Â    int producedUnits;**
**Â    bool handlesSea;**
};

struct RegistryItem {
**Â    int id;**
**Â    char name[64];**
**Â    int node;**
**Â    bool isFactory;**
};

/* ===========================
**Â   GLOBAL STORAGE (arrays)**
**Â   =========================== */**
Request requests[MAX_REQUESTS]; int requestsCount = 0;
int requestHeapArr[MAX_REQUESTS]; int requestHeapSize = 0; // max-heap indexes into requests[]

Truck trucks[MAX_TRUCKS]; int trucksCount = 0;
Boat boats[MAX_BOATS]; int boatsCount = 0;

Factory factories[MAX_FACTORIES]; int factoriesCount = 0;

/* Graph */
int nodesCount = 0;
int adjMat[MAX_NODES][MAX_NODES];

void initGraph(int n) {
**Â    nodesCount = n;**
**Â    for (int i=0;i<n;i++) for (int j=0;j<n;j++) adjMat[i][j] = (i==j?0:INF);**
}
void addEdge(int u,int v,int w) {
**Â    if (u<0||v<0||u>=nodesCount||v>=nodesCount) return;**
**Â    adjMat[u][v] = w; adjMat[v][u] = w;**
}

/* ===========================
**Â   AVL Registry (no vectors)**
**Â   =========================== */**
struct AVLNode {
**Â    RegistryItem it;**
**Â    AVLNode *left, *right;**
**Â    int height;**
**Â    AVLNode(const RegistryItem &x) { it = x; left = right = nullptr; height = 1; }**
};
AVLNode* registryRoot = nullptr;
int avlHeight(AVLNode* n) { return n ? n->height : 0; }
AVLNode* rightRotateAVL(AVLNode* y) {
**Â    AVLNode* x = y->left; AVLNode* T2 = x->right;**
**Â    x->right = y; y->left = T2;**
**Â    y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));**
**Â    x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));**
**Â    return x;**
}
AVLNode* leftRotateAVL(AVLNode* x) {
**Â    AVLNode* y = x->right; AVLNode* T2 = y->left;**
**Â    y->left = x; x->right = T2;**
**Â    x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));**
**Â    y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));**
**Â    return y;**
}
AVLNode* avlInsert(AVLNode* node, const RegistryItem &it) {
**Â    if (!node) return new AVLNode(it);**
**Â    if (it.id < node->it.id) node->left = avlInsert(node->left, it);**
**Â    else if (it.id > node->it.id) node->right = avlInsert(node->right, it);**
**Â    else return node;**
**Â    node->height = 1 + max(avlHeight(node->left), avlHeight(node->right));**
**Â    int balance = avlHeight(node->left) - avlHeight(node->right);**
**Â    if (balance > 1 && it.id < node->left->it.id) return rightRotateAVL(node);**
**Â    if (balance < -1 && it.id > node->right->it.id) return leftRotateAVL(node);**
**Â    if (balance > 1 && it.id > node->left->it.id) { node->left = leftRotateAVL(node->left); return rightRotateAVL(node); }**
**Â    if (balance < -1 && it.id < node->right->it.id) { node->right = rightRotateAVL(node->right); return leftRotateAVL(node); }**
**Â    return node;**
}
AVLNode* avlSearch(AVLNode* root, int id) {
**Â    if (!root) return nullptr;**
**Â    if (id == root->it.id) return root;**
**Â    if (id < root->it.id) return avlSearch(root->left, id);**
**Â    return avlSearch(root->right, id);**
}
void registerEntity(int id, const char* name, int node, bool isFactory) {
**Â    RegistryItem it; it.id = id; strncpy(it.name, name, sizeof(it.name)-1); it.name[sizeof(it.name)-1]=0; it.node = node; it.isFactory = isFactory;**
**Â    registryRoot = avlInsert(registryRoot, it);**
}

/* ===========================
**Â   MAX-HEAP: request priority queue (priority by priority, then earlier timestamp)**
**Â   computePriority includes hazardous strong bias**
**Â   =========================== */**
int computePriority(WasteType t, int volume, int timestamp, bool urgentFlag=false) {
**Â    int base = 0;**
**Â    if (t == W_HAZARDOUS) base += 200;**
**Â    else if (t == W_SEA_AQUATIC) base += 120;**
**Â    else if (t == W_INDUSTRIAL) base += 100;**
**Â    else if (t == W_COMMERCIAL) base += 60;**
**Â    else base += 30;**
**Â    int volScore = min(100, volume / 5);**
**Â    int urgency = urgentFlag ? 100 : 0;**
**Â    int timePenalty = timestamp/100; // older smaller timestamp => less penalty, but keep small impact**
**Â    return base + volScore + urgency - timePenalty;**
}
void requestHeapPush(int reqIdx) {
**Â    requestHeapArr[requestHeapSize] = reqIdx;**
**Â    int i = requestHeapSize++;**
**Â    while (i != 0) {**
**Â        int p = (i-1)/2;**
**Â        Request &cur = requests[ requestHeapArr[i] ];**
**Â        Request &par = requests[ requestHeapArr[p] ];**
**Â        if (cur.priority > par.priority || (cur.priority==par.priority && cur.timestamp < par.timestamp)) {**
**Â            int tmp = requestHeapArr[i]; requestHeapArr[i] = requestHeapArr[p]; requestHeapArr[p] = tmp;**
**Â            i = p;**
**Â        } else break;**
**Â    }**
}
int requestHeapPop() {
**Â    if (requestHeapSize == 0) return -1;**
**Â    int root = requestHeapArr[0];**
**Â    requestHeapArr[0] = requestHeapArr[--requestHeapSize];**
**Â    int i = 0;**
**Â    while (true) {**
**Â        int l = 2*i+1, r = 2*i+2, largest = i;**
**Â        if (l < requestHeapSize) {**
**Â            Request &L = requests[ requestHeapArr[l] ], &I = requests[ requestHeapArr[largest] ];**
**Â            if (L.priority > I.priority || (L.priority==I.priority && L.timestamp < I.timestamp)) largest = l;**
**Â        }**
**Â        if (r < requestHeapSize) {**
**Â            Request &R = requests[ requestHeapArr[r] ], &I = requests[ requestHeapArr[largest] ];**
**Â            if (R.priority > I.priority || (R.priority==I.priority && R.timestamp < I.timestamp)) largest = r;**
**Â        }**
**Â        if (largest != i) { int tmp = requestHeapArr[i]; requestHeapArr[i] = requestHeapArr[largest]; requestHeapArr[largest] = tmp; i = largest; }**
**Â        else break;**
**Â    }**
**Â    return root;**
}

/* ===========================
**Â   Add / load / save requests**
**Â   =========================== */**
void addRequest(int node, WasteType wt, int volume, int timestamp, bool urgent=false) {
**Â    if (requestsCount >= MAX_REQUESTS) { cout << "Request storage full\n"; return; }**
**Â    Request &r = requests[requestsCount];**
**Â    r.id = 100000 + requestsCount;**
**Â    r.node = node; r.type = wt; r.volume = volume; r.timestamp = timestamp;**
**Â    r.priority = computePriority(wt, volume, timestamp, urgent);**
**Â    r.processed = false; r.assigned = false; r.assignedVehicleId = -1;**
**Â    requestHeapPush(requestsCount);**
**Â    requestsCount++;**
}
void saveRequestsCSV(const char* fname) {
**Â    ofstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    f<<"id,node,type,volume,priority,timestamp,processed\n";**
**Â    for (int i=0;i<requestsCount;i++) {**
**Â        f<<requests[i].id<<","<<requests[i].node<<","<<int(requests[i].type)<<","<<requests[i].volume<<","<<requests[i].priority<<","<<requests[i].timestamp<<","<<requests[i].processed<<"\n";**
**Â    }**
**Â    f.close(); cout<<"Requests saved to "<<fname<<"\n";**
}
void loadRequestsCSV(const char* fname) {
**Â    ifstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    string line; getline(f,line); // header**
**Â    requestsCount = 0; requestHeapSize = 0;**
**Â    while(getline(f,line) && requestsCount < MAX_REQUESTS) {**
**Â        // parse CSV simple**
**Â        int id,node,type,volume,priority,timestamp,processed;**
**Â        char buf[512]; strncpy(buf,line.c_str(),511); buf[511]=0;**
**Â        // naive parse with sscanf**
**Â        if (sscanf(buf,"%d,%d,%d,%d,%d,%d,%d",&id,&node,&type,&volume,&priority,&timestamp,&processed) >= 7) {**
**Â            Request &r = requests[requestsCount];**
**Â            r.id = id; r.node = node; r.type = (WasteType)type; r.volume = volume; r.priority = priority; r.timestamp = timestamp; r.processed = processed; r.assigned=false; r.assignedVehicleId=-1;**
**Â            requestHeapPush(requestsCount);**
**Â            requestsCount++;**
**Â        }**
**Â    }**
**Â    f.close(); cout<<"Loaded "<<requestsCount<<" requests from "<<fname<<"\n";**
}

/* ===========================
**Â   Trucks & Boats management**
**Â   =========================== */**
void addTruck(int id, int startNode, int capacity, int speed) {
**Â    if (trucksCount >= MAX_TRUCKS) { cout<<"Truck capacity full\n"; return; }**
**Â    trucks[trucksCount].c.id = id; trucks[trucksCount].c.currentNode = startNode; trucks[trucksCount].c.capacity = capacity; trucks[trucksCount].c.load = 0; trucks[trucksCount].c.available = true; trucks[trucksCount].c.speed = speed; trucks[trucksCount].c.destNode = -1; trucks[trucksCount].c.remainingDist = 0; trucks[trucksCount].c.assignedRequestIdx = -1; trucksCount++;**
}
void addBoat(int id, int startNode, int capacity, int speed) {
**Â    if (boatsCount >= MAX_BOATS) { cout<<"Boat capacity full\n"; return; }**
**Â    boats[boatsCount].c.id = id; boats[boatsCount].c.currentNode = startNode; boats[boatsCount].c.capacity = capacity; boats[boatsCount].c.load = 0; boats[boatsCount].c.available = true; boats[boatsCount].c.speed = speed; boats[boatsCount].c.destNode = -1; boats[boatsCount].c.remainingDist = 0; boats[boatsCount].c.assignedRequestIdx = -1; boats[boatsCount].sea_enabled = true; boatsCount++;**
}
void saveVehiclesCSV(const char* fname) {
**Â    ofstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    f<<"type,id,node,capacity,speed,available,load\n";**
**Â    for (int i=0;i<trucksCount;i++) f<<"truck,"<<trucks[i].c.id<<","<<trucks[i].c.currentNode<<","<<trucks[i].c.capacity<<","<<trucks[i].c.speed<<","<<trucks[i].c.available<<","<<trucks[i].c.load<<"\n";**
**Â    for (int i=0;i<boatsCount;i++) f<<"boat,"<<boats[i].c.id<<","<<boats[i].c.currentNode<<","<<boats[i].c.capacity<<","<<boats[i].c.speed<<","<<boats[i].c.available<<","<<boats[i].c.load<<"\n";**
**Â    f.close(); cout<<"Vehicles saved to "<<fname<<"\n";**
}
void loadVehiclesCSV(const char* fname) {
**Â    ifstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    string line; getline(f,line);**
**Â    trucksCount = 0; boatsCount = 0;**
**Â    while(getline(f,line) && (trucksCount < MAX_TRUCKS || boatsCount < MAX_BOATS)) {**
**Â        char type[32]; int id,node,capacity,speed,available,load;**
**Â        char buf[512]; strncpy(buf,line.c_str(),511); buf[511]=0;**
**Â        if (sscanf(buf,"%31[^,],%d,%d,%d,%d,%d,%d",type,&id,&node,&capacity,&speed,&available,&load) >= 7) {**
**Â            if (strcmp(type,"truck")==0 && trucksCount < MAX_TRUCKS) {**
**Â                addTruck(id,node,capacity,speed); trucks[trucksCount-1].c.available = (available!=0); trucks[trucksCount-1].c.load = load;**
**Â            } else if (strcmp(type,"boat")==0 && boatsCount < MAX_BOATS) {**
**Â                addBoat(id,node,capacity,speed); boats[boatsCount-1].c.available = (available!=0); boats[boatsCount-1].c.load = load;**
**Â            }**
**Â        }**
**Â    }**
**Â    f.close();**
**Â    cout<<"Loaded trucks="<<trucksCount<<" boats="<<boatsCount<<" from "<<fname<<"\n";**
}

/* ===========================
**Â   Factories: add/save/load**
**Â   =========================== */**
void addFactoryEntry(int id, const char* name, int node, int capacityIn, bool handlesSea) {
**Â    if (factoriesCount >= MAX_FACTORIES) { cout<<"Factories full\n"; return; }**
**Â    Factory &f = factories[factoriesCount++];**
**Â    f.id = id; strncpy(f.name, name, sizeof(f.name)-1); f.name[sizeof(f.name)-1]=0; f.node = node; f.capacityIn = capacityIn; f.storedRaw = 0; f.producedUnits = 0; f.handlesSea = handlesSea;**
**Â    // register entity**
**Â    registerEntity(id, name, node, true);**
}
void saveFactoriesCSV(const char* fname) {
**Â    ofstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    f<<"id,name,node,capacityIn,storedRaw,producedUnits,handlesSea\n";**
**Â    for (int i=0;i<factoriesCount;i++) {**
**Â        f<<factories[i].id<<","<<factories[i].name<<","<<factories[i].node<<","<<factories[i].capacityIn<<","<<factories[i].storedRaw<<","<<factories[i].producedUnits<<","<<factories[i].handlesSea<<"\n";**
**Â    }**
**Â    f.close(); cout<<"Factories saved to "<<fname<<"\n";**
}
void loadFactoriesCSV(const char* fname) {
**Â    ifstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    string line; getline(f,line);**
**Â    factoriesCount = 0;**
**Â    while(getline(f,line) && factoriesCount < MAX_FACTORIES) {**
**Â        char buf[512]; strncpy(buf,line.c_str(),511); buf[511]=0;**
**Â        int id,node,capacityIn,storedRaw,producedUnits,handlesSea;**
**Â        char name[64];**
**Â        if (sscanf(buf,"%d,%63[^,],%d,%d,%d,%d,%d",&id,name,&node,&capacityIn,&storedRaw,&producedUnits,&handlesSea) >= 7) {**
**Â            addFactoryEntry(id,name,node,capacityIn,handlesSea!=0);**
**Â            factories[factoriesCount-1].storedRaw = storedRaw; factories[factoriesCount-1].producedUnits = producedUnits;**
**Â        }**
**Â    }**
**Â    f.close(); cout<<"Loaded "<<factoriesCount<<" factories from "<<fname<<"\n";**
}

/* ===========================
**Â   Dijkstra (array-based) returns parent & dist arrays**
**Â   =========================== */**
struct DRes { int dist[MAX_NODES]; int parent[MAX_NODES]; };
DRes dijkstraArray(int src) {
**Â    DRes R; bool used[MAX_NODES];**
**Â    for (int i=0;i<nodesCount;i++) { R.dist[i]=INF; R.parent[i]=-1; used[i]=false; }**
**Â    R.dist[src] = 0;**
**Â    for (int iter=0; iter<nodesCount; iter++) {**
**Â        int u=-1, best=INF;**
**Â        for (int i=0;i<nodesCount;i++) if (!used[i] && R.dist[i]<best) { best = R.dist[i]; u = i; }**
**Â        if (u==-1) break;**
**Â        used[u] = true;**
**Â        for (int v=0; v<nodesCount; v++) {**
**Â            if (adjMat[u][v] < INF && R.dist[u] + adjMat[u][v] < R.dist[v]) {**
**Â                R.dist[v] = R.dist[u] + adjMat[u][v];**
**Â                R.parent[v] = u;**
**Â            }**
**Â        }**
**Â    }**
**Â    return R;**
}
int computePathLenFromParent(int parent[], int target) {
**Â    int cur = target; int sum = 0;**
**Â    while (parent[cur] != -1) {**
**Â        int p = parent[cur];**
**Â        sum += adjMat[p][cur];**
**Â        cur = p;**
**Â    }**
**Â    return sum;**
}

/* ===========================
**Â   Dispatch: assign nearest suitable vehicle (truck or boat) based on waste type & availability**
**Â   time-accurate: assign destination and remainingDist; movement simulated by ticks**
**Â   =========================== */**
int findFactoryFor(WasteType wt, int volume) {
**Â    int best = -1; int bestFree = -1;**
**Â    for (int i=0;i<factoriesCount;i++) {**
**Â        if (wt == W_SEA_AQUATIC && !factories[i].handlesSea) continue;**
**Â        int freeCap = factories[i].capacityIn - factories[i].storedRaw;**
**Â        if (freeCap >= volume && freeCap > bestFree) { best = i; bestFree = freeCap; }**
**Â    }**
**Â    if (best == -1) {**
**Â        for (int i=0;i<factoriesCount;i++) {**
**Â            if (wt == W_SEA_AQUATIC && !factories[i].handlesSea) continue;**
**Â            int freeCap = factories[i].capacityIn - factories[i].storedRaw;**
**Â            if (freeCap > 0) { best = i; break; }**
**Â        }**
**Â    }**
**Â    return best;**
}
void dispatchTopRequest(int currentTime) {
**Â    if (requestHeapSize == 0) return;**
**Â    int reqIdx = requestHeapPop();**
**Â    if (reqIdx < 0) return;**
**Â    Request &rq = requests[reqIdx];**
**Â    if (rq.processed || rq.assigned) return;**
**Â    // choose vehicle type**
**Â    bool needBoat = (rq.type == W_SEA_AQUATIC);**
**Â    // First look for dedicated vehicle (truck/boat) nearest by Dijkstra distance**
**Â    int chosenVehicleType = -1; // 0=truck,1=boat**
**Â    int chosenIdx = -1;**
**Â    int chosenDist = INF;**
**Â    // trucks**
**Â    for (int t=0;t<trucksCount;t++) {**
**Â        if (!trucks[t].c.available) continue;**
**Â        if (trucks[t].c.capacity - trucks[t].c.load < rq.volume) continue;**
**Â        DRes dr = dijkstraArray(trucks[t].c.currentNode);**
**Â        if (dr.dist[rq.node] < chosenDist) { chosenDist = dr.dist[rq.node]; chosenVehicleType = 0; chosenIdx = t; }**
**Â    }**
**Â    // boats if needed or if no truck found and boats exist**
**Â    if (boatsCount > 0) {**
**Â        for (int b=0;b<boatsCount;b++) {**
**Â            if (!boats[b].c.available) continue;**
**Â            if (boats[b].c.capacity - boats[b].c.load < rq.volume) continue;**
**Â            DRes dr = dijkstraArray(boats[b].c.currentNode);**
**Â            // if request is sea and boat is closer, prefer boat**
**Â            if (dr.dist[rq.node] < chosenDist) { chosenDist = dr.dist[rq.node]; chosenVehicleType = 1; chosenIdx = b; }**
**Â        }**
**Â    }**
**Â    // If hazardous request, try to find any vehicle; hazard bias would have made priority high and it'll get chosen early**
**Â    if (chosenIdx == -1) {**
**Â        // no vehicle available now: requeue with slight time penalty (so others can be processed)**
**Â        rq.priority = max(0, rq.priority - 1);**
**Â        requestHeapPush(reqIdx);**
**Â        return;**
**Â    }**
**Â    // Determine factory**
**Â    int fIdx = findFactoryFor(rq.type, rq.volume);**
**Â    if (fIdx == -1) {**
**Â        // No factory; if hazardous, escalate (we can send to nearest allowed factory regardless of free capacity)**
**Â        int fallback = -1; int minDist = INF;**
**Â        for (int i=0;i<factoriesCount;i++) {**
**Â            if (rq.type==W_SEA_AQUATIC && !factories[i].handlesSea) continue;**
**Â            DRes dr = dijkstraArray(rq.node);**
**Â            if (dr.dist[factories[i].node] < minDist) { minDist = dr.dist[factories[i].node]; fallback = i; }**
**Â        }**
**Â        if (fallback != -1) fIdx = fallback;**
**Â        else {**
**Â            cout<<"[WARN] No factory available for request "<<rq.id<<". Marking as failed.\n";**
**Â            rq.processed = true;**
**Â            return;**
**Â        }**
**Â    }**
**Â    // Assign chosen vehicle: set destination to request node then to factory (we simulate multi-leg by setting destNode=request.node and storing assignedRequest)**
**Â    if (chosenVehicleType == 0) {**
**Â        Truck &tr = trucks[chosenIdx];**
**Â        tr.c.available = false;**
**Â        tr.c.assignedRequestIdx = reqIdx;**
**Â        // compute distance from truck.currentNode -> request.node**
**Â        DRes drTruckToReq = dijkstraArray(tr.c.currentNode);**
**Â        int distToReq = drTruckToReq.dist[rq.node];**
**Â        tr.c.destNode = rq.node;**
**Â        tr.c.remainingDist = (distToReq>=INF? INF: distToReq);**
**Â        // store assigned vehicle id into request**
**Â        rq.assigned = true; rq.assignedVehicleId = tr.c.id;**
**Â        cout<<"[ASSIGN] Truck "<<tr.c.id<<" assigned to Request "<<rq.id<<" (distToReq="<<distToReq<<") and will deliver to Factory "<<factories[fIdx].name<<"\n";**
**Â        // We will store factory index somewhere: for simplicity, we temporarily attach to requestsCount field? better store in processed flag mapping? We'll store assignedVehicleId and vehicle will know assignedRequestIdx, and on delivery we'll find factory by type+volume**
**Â        // Keep rq.processed false until delivered**
**Â    } else {**
**Â        Boat &bo = boats[chosenIdx];**
**Â        bo.c.available = false;**
**Â        bo.c.assignedRequestIdx = reqIdx;**
**Â        DRes drBoatToReq = dijkstraArray(bo.c.currentNode);**
**Â        int distToReq = drBoatToReq.dist[rq.node];**
**Â        bo.c.destNode = rq.node;**
**Â        bo.c.remainingDist = (distToReq>=INF? INF: distToReq);**
**Â        rq.assigned = true; rq.assignedVehicleId = bo.c.id;**
**Â        cout<<"[ASSIGN] Boat "<<bo.c.id<<" assigned to Request "<<rq.id<<" (distToReq="<<distToReq<<") and will deliver to Factory "<<factories[fIdx].name<<"\n";**
**Â    }**
}

/* ===========================
**Â   Movement simulation tick: move vehicles toward dest; when reach request node, load and send to factory**
**Â   We implement states:**
**Â   - vehicle.destNode == request.node : moving to pickup**
**Â   - when arrive, immediate compute factory and set destNode = factory.node and remainingDist accordingly**
**Â   - when arrive at factory, unload -> factory.storedRaw += volume; mark request.processed = true**
**Â   =========================== */**
void processTick(int currentTime) {
**Â    // trucks**
**Â    for (int t=0;t<trucksCount;t++) {**
**Â        Truck &tr = trucks[t];**
**Â        if (tr.c.destNode == -1) continue;**
**Â        if (tr.c.remainingDist <= 0) {**
**Â            // arrived at dest node**
**Â            int reqIdx = tr.c.assignedRequestIdx;**
**Â            if (reqIdx < 0 || reqIdx >= requestsCount) { tr.c.destNode = -1; tr.c.available = true; continue; }**
**Â            Request &rq = requests[reqIdx];**
**Â            if (!rq.assigned) { tr.c.destNode = -1; tr.c.available = true; tr.c.assignedRequestIdx = -1; continue; }**
**Â            // If at pickup point and not yet loaded**
**Â            if (!rq.processed && tr.c.currentNode == rq.node) {**
**Â                // load into truck**
**Â                if (tr.c.capacity - tr.c.load >= rq.volume) {**
**Â                    tr.c.load += rq.volume;**
**Â                    // set next destination = best factory**
**Â                    int fIdx = findFactoryFor(rq.type, rq.volume);**
**Â                    if (fIdx == -1) {**
**Â                        // no factory -> unload to temp depot (skip)**
**Â                        cout<<"[WARN] No factory when truck arrived for request "<<rq.id<<". Unloading at depot.\n";**
**Â                        tr.c.load -= rq.volume;**
**Â                        rq.processed = true;**
**Â                        tr.c.destNode = -1; tr.c.assignedRequestIdx = -1; tr.c.available = true;**
**Â                    } else {**
**Â                        // set path to factory**
**Â                        DRes dr = dijkstraArray(tr.c.currentNode);**
**Â                        int distToFactory = dr.dist[ factories[fIdx].node ];**
**Â                        tr.c.destNode = factories[fIdx].node;**
**Â                        tr.c.remainingDist = (distToFactory>=INF? INF: distToFactory);**
**Â                        // store selected factory id in assignedVehicleId? we will simply on arrival iterate best factory again and add**
**Â                        cout<<"[TRUCK] Truck "<<tr.c.id<<" loaded "<<rq.volume<<"L for Request "<<rq.id<<", heading to Factory "<<factories[fIdx].name<<" (dist="<<distToFactory<<")\n";**
**Â                    }**
**Â                } else {**
**Â                    // not enough capacity (shouldn't happen due to check earlier) -> requeue or partial load (skip)**
**Â                    cout<<"[WARN] Truck "<<tr.c.id<<" cannot load full volume for request "<<rq.id<<"\n";**
**Â                }**
**Â            } else if (!rq.processed && tr.c.currentNode == tr.c.destNode) {**
**Â                // arrived at factory (assuming destNode is factory)**
**Â                int fIdx = -1;**
**Â                // find factory at this node**
**Â                for (int i=0;i<factoriesCount;i++) if (factories[i].node == tr.c.currentNode) { fIdx = i; break; }**
**Â                if (fIdx == -1) {**
**Â                    // not factory node -> free vehicle**
**Â                    tr.c.destNode = -1; tr.c.available = true; tr.c.assignedRequestIdx = -1;**
**Â                } else {**
**Â                    // unload**
**Â                    // find request for this truck**
**Â                    if (rq.volume <= tr.c.load) {**
**Â                        factories[fIdx].storedRaw += rq.volume;**
**Â                        tr.c.load -= rq.volume;**
**Â                        rq.processed = true;**
**Â                        cout<<"[DELIVER] Truck "<<tr.c.id<<" delivered "<<rq.volume<<"L for Request "<<rq.id<<" to Factory "<<factories[fIdx].name<<"\n";**
**Â                        // free truck**
**Â                        tr.c.destNode = -1; tr.c.available = true; tr.c.assignedRequestIdx = -1;**
**Â                    } else {**
**Â                        // partial handling**
**Â                        factories[fIdx].storedRaw += tr.c.load;**
**Â                        rq.volume -= tr.c.load;**
**Â                        cout<<"[PARTIAL] Truck "<<tr.c.id<<" partially delivered to Factory "<<factories[fIdx].name<<" remaining for request "<<rq.id<<" = "<<rq.volume<<"\n";**
**Â                        tr.c.load = 0;**
**Â                        tr.c.destNode = -1; tr.c.available = true; tr.c.assignedRequestIdx = -1;**
**Â                        // requeue remaining (adjust priority)**
**Â                        rq.priority = max(0, rq.priority - 1);**
**Â                        requestHeapPush(reqIdx);**
**Â                    }**
**Â                }**
**Â            } else {**
**Â                // arrived at some node but conditions not matching - free vehicle**
**Â                tr.c.destNode = -1; tr.c.available = true; tr.c.assignedRequestIdx = -1;**
**Â            }**
**Â        } else {**
**Â            // move towards destination by speed units**
**Â            int move = tr.c.speed;**
**Â            tr.c.remainingDist -= move;**
**Â            // if remainingDist becomes <=0, set currentNode to destNode**
**Â            if (tr.c.remainingDist <= 0) tr.c.currentNode = tr.c.destNode;**
**Â            // else we don't update intermediate node (requires path step simulation)**
**Â        }**
**Â    }**
**Â    // boats: similar logic**
**Â    for (int b=0;b<boatsCount;b++) {**
**Â        Boat &bo = boats[b];**
**Â        if (bo.c.destNode == -1) continue;**
**Â        if (bo.c.remainingDist <= 0) {**
**Â            int reqIdx = bo.c.assignedRequestIdx;**
**Â            if (reqIdx < 0 || reqIdx >= requestsCount) { bo.c.destNode = -1; bo.c.available = true; continue; }**
**Â            Request &rq = requests[reqIdx];**
**Â            if (!rq.assigned) { bo.c.destNode = -1; bo.c.available = true; bo.c.assignedRequestIdx = -1; continue; }**
**Â            if (!rq.processed && bo.c.currentNode == rq.node) {**
**Â                if (bo.c.capacity - bo.c.load >= rq.volume) {**
**Â                    bo.c.load += rq.volume;**
**Â                    int fIdx = findFactoryFor(rq.type, rq.volume);**
**Â                    if (fIdx == -1) {**
**Â                        cout<<"[WARN] No factory when boat arrived for request "<<rq.id<<". Unloading at depot.\n";**
**Â                        bo.c.load -= rq.volume;**
**Â                        rq.processed = true;**
**Â                        bo.c.destNode = -1; bo.c.assignedRequestIdx = -1; bo.c.available = true;**
**Â                    } else {**
**Â                        DRes dr = dijkstraArray(bo.c.currentNode);**
**Â                        int distToFactory = dr.dist[ factories[fIdx].node ];**
**Â                        bo.c.destNode = factories[fIdx].node;**
**Â                        bo.c.remainingDist = (distToFactory>=INF? INF: distToFactory);**
**Â                        cout<<"[BOAT] Boat "<<bo.c.id<<" loaded "<<rq.volume<<"L for Request "<<rq.id<<", heading to Factory "<<factories[fIdx].name<<"\n";**
**Â                    }**
**Â                } else {**
**Â                    cout<<"[WARN] Boat "<<bo.c.id<<" cannot load full volume for request "<<rq.id<<"\n";**
**Â                }**
**Â            } else if (!rq.processed && bo.c.currentNode == bo.c.destNode) {**
**Â                int fIdx = -1;**
**Â                for (int i=0;i<factoriesCount;i++) if (factories[i].node == bo.c.currentNode) { fIdx = i; break; }**
**Â                if (fIdx == -1) { bo.c.destNode = -1; bo.c.available = true; bo.c.assignedRequestIdx = -1; }**
**Â                else {**
**Â                    if (rq.volume <= bo.c.load) {**
**Â                        factories[fIdx].storedRaw += rq.volume;**
**Â                        bo.c.load -= rq.volume;**
**Â                        rq.processed = true;**
**Â                        cout<<"[DELIVER] Boat "<<bo.c.id<<" delivered "<<rq.volume<<"L for Request "<<rq.id<<" to Factory "<<factories[fIdx].name<<"\n";**
**Â                        bo.c.destNode = -1; bo.c.available = true; bo.c.assignedRequestIdx = -1;**
**Â                    } else {**
**Â                        factories[fIdx].storedRaw += bo.c.load;**
**Â                        rq.volume -= bo.c.load;**
**Â                        cout<<"[PARTIAL] Boat "<<bo.c.id<<" partially delivered to Factory "<<factories[fIdx].name<<" remaining for request "<<rq.id<<" = "<<rq.volume<<"\n";**
**Â                        bo.c.load = 0;**
**Â                        bo.c.destNode = -1; bo.c.available = true; bo.c.assignedRequestIdx = -1;**
**Â                        rq.priority = max(0, rq.priority - 1);**
**Â                        requestHeapPush(reqIdx);**
**Â                    }**
**Â                }**
**Â            } else {**
**Â                bo.c.destNode = -1; bo.c.available = true; bo.c.assignedRequestIdx = -1;**
**Â            }**
**Â        } else {**
**Â            int move = bo.c.speed;**
**Â            bo.c.remainingDist -= move;**
**Â            if (bo.c.remainingDist <= 0) bo.c.currentNode = bo.c.destNode;**
**Â        }**
**Â    }**
}

/* ===========================
**Â   Factory processing: convert raw -> units**
**Â   =========================== */**
void processFactories() {
**Â    for (int i=0;i<factoriesCount;i++) {**
**Â        Factory &f = factories[i];**
**Â        if (f.storedRaw <= 0) continue;**
**Â        int units = f.storedRaw / 100; // 100L -> 1 unit**
**Â        if (units > 0) {**
**Â            f.producedUnits += units;**
**Â            f.storedRaw -= units * 100;**
**Â            cout<<"[FACTORY] "<<f.name<<" processed "<<units*100<<"L -> "<<units<<" units (total units="<<f.producedUnits<<")\n";**
**Â        }**
**Â    }**
}

/* ===========================
**Â   Merge sort factories by producedUnits descending for report**
**Â   =========================== */**
void mergeFactories(Factory arr[], int l, int m, int r) {
**Â    int n1 = m-l+1, n2 = r-m;**
**Â    Factory *L = new Factory[n1]; Factory *R = new Factory[n2];**
**Â    for (int i=0;i<n1;i++) L[i] = arr[l+i];**
**Â    for (int j=0;j<n2;j++) R[j] = arr[m+1+j];**
**Â    int i=0,j=0,k=l;**
**Â    while (i<n1 && j<n2) {**
**Â        if (L[i].producedUnits >= R[j].producedUnits) arr[k++] = L[i++]; else arr[k++] = R[j++];**
**Â    }**
**Â    while (i<n1) arr[k++] = L[i++];**
**Â    while (j<n2) arr[k++] = R[j++];**
**Â    delete[] L; delete[] R;**
}
void mergeSortFactoriesArr(Factory arr[], int l, int r) {
**Â    if (l<r) {**
**Â        int m = (l+r)/2;**
**Â        mergeSortFactoriesArr(arr,l,m); mergeSortFactoriesArr(arr,m+1,r); mergeFactories(arr,l,m,r);**
**Â    }**
}

/* ===========================
**Â   KMP substring search for names**
**Â   =========================== */**
void computeLPS(const char pat[], int M, int lps[]) {
**Â    int len=0; lps[0]=0; int i=1;**
**Â    while (i<M) {**
**Â        if (pat[i] == pat[len]) { len++; lps[i]=len; i++; }**
**Â        else { if (len) len=lps[len-1]; else { lps[i]=0; i++; } }**
**Â    }**
}
bool KMPsearch(const char text[], const char pat[]) {
**Â    int N = strlen(text), M = strlen(pat);**
**Â    if (M==0) return true;**
**Â    int *lps = new int[M];**
**Â    computeLPS(pat,M,lps);**
**Â    int i=0,j=0;**
**Â    while (i<N) {**
**Â        if (text[i] == pat[j]) { i++; j++; if (j==M) { delete[] lps; return true; } }**
**Â        else { if (j) j = lps[j-1]; else i++; }**
**Â    }**
**Â    delete[] lps; return false;**
}

/* ===========================
**Â   Persistence: save/load all major tables**
**Â   =========================== */**
void saveAll(const char* dir) {
**Â    char fname[256];**
**Â    snprintf(fname,sizeof(fname),"%s/requests.csv",dir); saveRequestsCSV(fname);**
**Â    snprintf(fname,sizeof(fname),"%s/vehicles.csv",dir); saveVehiclesCSV(fname);**
**Â    snprintf(fname,sizeof(fname),"%s/factories.csv",dir); saveFactoriesCSV(fname);**
**Â    cout<<"Saved all data to directory: "<<dir<<"\n";**
}
void loadAll(const char* dir) {
**Â    char fname[256];**
**Â    snprintf(fname,sizeof(fname),"%s/requests.csv",dir); loadRequestsCSV(fname);**
**Â    snprintf(fname,sizeof(fname),"%s/vehicles.csv",dir); loadVehiclesCSV(fname);**
**Â    snprintf(fname,sizeof(fname),"%s/factories.csv",dir); loadFactoriesCSV(fname);**
**Â    cout<<"Loaded all data from directory: "<<dir<<"\n";**
}

/* ===========================
**Â   Save/Load functions require forward declarations from above**
**Â   =========================== */**
void saveRequestsCSV(const char* fname);
void loadRequestsCSV(const char* fname);
void saveVehiclesCSV(const char* fname);
void loadVehiclesCSV(const char* fname);
void saveFactoriesCSV(const char* fname);
void loadFactoriesCSV(const char* fname);

/* ===========================
**Â   DEMO SETUP**
**Â   =========================== */**
void demoSetup() {
**Â    initGraph(20);**
**Â    // build sample map (nodes)**
**Â    addEdge(0,1,5); addEdge(0,2,7); addEdge(1,3,4); addEdge(2,4,6);**
**Â    addEdge(3,5,3); addEdge(4,6,2); addEdge(5,7,5); addEdge(6,8,4);**
**Â    addEdge(7,9,7); addEdge(9,10,3); addEdge(10,11,4); addEdge(11,12,6);**
**Â    // factories**
**Â    addFactoryEntry:**
**Â    // use addFactoryEntry wrapper (we already have addFactoryEntry earlier) -> but name conflict; implement simple here:**
**Â    addFactoryEntry(501,"RecycCo General",6,3000,false);**
**Â    addFactoryEntry(502,"MarineClean",9,4000,true);**
**Â    addFactoryEntry(503,"InduRecycle",4,2500,false);**
**Â    // register factories in AVL**
**Â    registerEntity(501,"RecycCo General",6,true);**
**Â    registerEntity(502,"MarineClean",9,true);**
**Â    registerEntity(503,"InduRecycle",4,true);**
**Â    // trucks and boats**
**Â    addTruck(201,0,1500,20);**
**Â    addTruck(202,2,1000,18);**
**Â    addBoat(301,9,2000,15);**
**Â    // sample household registrations**
**Â    registerEntity(1001,"House-A",3,false);**
**Â    registerEntity(1002,"Shop-B",2,false);**
}

/* ===========================
**Â   CLI helpers**
**Â   =========================== */**
void showMenu() {
**Â    cout<<"\n=== Smart Waste System Menu ===\n";**
**Â    cout<<"1) Add Request\n2) Add Truck\n3) Add Boat\n4) Add Factory\n5) Dispatch next request\n6) Run simulation ticks\n7) Process factories (run processing once)\n8) Show reports (factories)\n9) Save all CSVs\n10) Load all CSVs\n11) List pending requests\n12) List vehicles\n13) Exit\nChoose: ";**
}
void listPendingRequests() {
**Â    cout<<"Pending Requests (id,node,type,vol,priority,timestamp,processed):\n";**
**Â    for (int i=0;i<requestsCount;i++) {**
**Â        Request &r = requests[i];**
**Â        cout<<r.id<<","<<r.node<<","<<WasteTypeName[r.type]<<","<<r.volume<<","<<r.priority<<","<<r.timestamp<<","<<r.processed<<"\n";**
**Â    }**
}
void listVehicles() {
**Â    cout<<"Trucks:\n";**
**Â    for (int i=0;i<trucksCount;i++) {**
**Â        Truck &t = trucks[i];**
**Â        cout<<"Truck id="<<t.c.id<<" node="<<t.c.currentNode<<" cap="<<t.c.capacity<<" load="<<t.c.load<<" avail="<<t.c.available<<"\n";**
**Â    }**
**Â    cout<<"Boats:\n";**
**Â    for (int i=0;i<boatsCount;i++) {**
**Â        Boat &b = boats[i];**
**Â        cout<<"Boat id="<<b.c.id<<" node="<<b.c.currentNode<<" cap="<<b.c.capacity<<" load="<<b.c.load<<" avail="<<b.c.available<<"\n";**
**Â    }**
}
void showFactoryReport() {
**Â    if (factoriesCount == 0) { cout<<"No factories\n"; return; }**
**Â    Factory copyArr[MAX_FACTORIES];**
**Â    int fc = factoriesCount;**
**Â    for (int i=0;i<fc;i++) copyArr[i] = factories[i];**
**Â    mergeSortFactoriesArr(copyArr, 0, fc-1);**
**Â    cout<<"Factory Report (by units desc):\n";**
**Â    for (int i=0;i<fc;i++) cout<<copyArr[i].name<<" units="<<copyArr[i].producedUnits<<" storedRaw="<<copyArr[i].storedRaw<<"\n";**
}

/* ===========================
**Â   wrapper for addFactoryEntry (we forward declared earlier)**
**Â   =========================== */**
void addFactoryEntry(int id, const char* name, int node, int capacityIn, bool handlesSea) {
**Â    if (factoriesCount >= MAX_FACTORIES) { cout<<"No space\n"; return; }**
**Â    Factory &f = factories[factoriesCount++];**
**Â    f.id = id; strncpy(f.name, name, sizeof(f.name)-1); f.name[sizeof(f.name)-1]=0; f.node=node; f.capacityIn = capacityIn; f.storedRaw = 0; f.producedUnits = 0; f.handlesSea = handlesSea;**
}

/* ===========================
**Â   Main: menu loop**
**Â   =========================== */**
int main() {
**Â    ios::sync_with_stdio(false);**
**Â    cin.tie(nullptr);**

**Â    cout<<"=== Smart Waste Collection & Recycling Management (Expanded) ===\n";**
**Â    demoSetup(); // sample world preloaded**

**Â    int currentTime = 0;**
**Â    while (true) {**
**Â        showMenu();**
**Â        int choice; if (!(cin>>choice)) break;**
**Â        if (choice == 1) {**
**Â            int node, vol; int ttype;**
**Â            char urgentch;**
**Â            cout<<"Enter node, type (0=household,1=commercial,2=industrial,3=sea,4=hazardous), volume: ";**
**Â            cin>>node>>ttype>>vol;**
**Â            cout<<"Urgent? (y/n): "; cin>>urgentch;**
**Â            bool urgent = (urgentch=='y'||urgentch=='Y');**
**Â            addRequest(node, (WasteType)ttype, vol, currentTime, urgent);**
**Â            cout<<"Added request.\n";**
**Â        } else if (choice == 2) {**
**Â            int id,node,cap,speed;**
**Â            cout<<"Enter truck id, startNode, capacity, speed (units/min): "; cin>>id>>node>>cap>>speed;**
**Â            addTruck(id,node,cap,speed);**
**Â            cout<<"Truck added.\n";**
**Â        } else if (choice == 3) {**
**Â            int id,node,cap,speed;**
**Â            cout<<"Enter boat id, startNode, capacity, speed: "; cin>>id>>node>>cap>>speed;**
**Â            addBoat(id,node,cap,speed);**
**Â            cout<<"Boat added.\n";**
**Â        } else if (choice == 4) {**
**Â            int id,node,cap; char name[64]; int handlesSea;**
**Â            cout<<"Enter factory id, name (single token), node, capacityIn, handlesSea(0/1): ";**
**Â            cin>>id>>name>>node>>cap>>handlesSea;**
**Â            addFactoryEntry(id,name,node,cap,handlesSea!=0);**
**Â            registerEntity(id,name,node,true);**
**Â            cout<<"Factory added.\n";**
**Â        } else if (choice == 5) {**
**Â            // dispatch top request**
**Â            dispatchTopRequest(currentTime);**
**Â        } else if (choice == 6) {**
**Â            int ticks; cout<<"How many minutes to simulate? "; cin>>ticks;**
**Â            for (int i=0;i<ticks;i++) {**
**Â                // dispatch new requests opportunistically**
**Â                if (requestHeapSize > 0) dispatchTopRequest(currentTime);**
**Â                processTick(currentTime);**
**Â                processFactories();**
**Â                currentTime++;**
**Â            }**
**Â            cout<<"Simulated "<<ticks<<" minute(s). CurrentTime="<<currentTime<<"\n";**
**Â        } else if (choice == 7) {**
**Â            processFactories(); cout<<"Factories processed once.\n";**
**Â        } else if (choice == 8) {**
**Â            showFactoryReport();**
**Â        } else if (choice == 9) {**
**Â            char dir[128]; cout<<"Enter directory path (no trailing slash) to save CSV files: "; cin>>dir;**
**Â            saveAll(dir);**
**Â        } else if (choice == 10) {**
**Â            char dir[128]; cout<<"Enter directory path to load CSV files: "; cin>>dir;**
**Â            loadAll(dir);**
**Â        } else if (choice == 11) {**
**Â            listPendingRequests();**
**Â        } else if (choice == 12) {**
**Â            listVehicles();**
**Â        } else if (choice == 13) {**
**Â            cout<<"Exiting.\n"; break;**
**Â        } else {**
**Â            cout<<"Invalid choice.\n";**
**Â        }**
**Â    }**

**Â    return 0;**
}

/* ===========================
**Â   CSV helper implementations (declared above)**
**Â   =========================== */**

void saveRequestsCSV(const char* fname) {
**Â    ofstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    f<<"id,node,type,volume,priority,timestamp,processed\n";**
**Â    for (int i=0;i<requestsCount;i++) {**
**Â        f<<requests[i].id<<","<<requests[i].node<<","<<int(requests[i].type)<<","<<requests[i].volume<<","<<requests[i].priority<<","<<requests[i].timestamp<<","<<requests[i].processed<<"\n";**
**Â    }**
**Â    f.close();**
}

void loadRequestsCSV(const char* fname) {
**Â    ifstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    string line; getline(f,line); // header**
**Â    requestsCount = 0; requestHeapSize = 0;**
**Â    while(getline(f,line) && requestsCount < MAX_REQUESTS) {**
**Â        int id,node,type,volume,priority,timestamp,processed;**
**Â        char buf[512]; strncpy(buf,line.c_str(),511); buf[511]=0;**
**Â        if (sscanf(buf,"%d,%d,%d,%d,%d,%d,%d",&id,&node,&type,&volume,&priority,&timestamp,&processed) >= 7) {**
**Â            Request &r = requests[requestsCount];**
**Â            r.id = id; r.node = node; r.type = (WasteType)type; r.volume = volume; r.priority = priority; r.timestamp = timestamp; r.processed = processed; r.assigned=false; r.assignedVehicleId=-1;**
**Â            requestHeapPush(requestsCount);**
**Â            requestsCount++;**
**Â        }**
**Â    }**
**Â    f.close();**
}

void saveVehiclesCSV(const char* fname) {
**Â    ofstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    f<<"type,id,node,capacity,speed,available,load\n";**
**Â    for (int i=0;i<trucksCount;i++) f<<"truck,"<<trucks[i].c.id<<","<<trucks[i].c.currentNode<<","<<trucks[i].c.capacity<<","<<trucks[i].c.speed<<","<<trucks[i].c.available<<","<<trucks[i].c.load<<"\n";**
**Â    for (int i=0;i<boatsCount;i++) f<<"boat,"<<boats[i].c.id<<","<<boats[i].c.currentNode<<","<<boats[i].c.capacity<<","<<boats[i].c.speed<<","<<boats[i].c.available<<","<<boats[i].c.load<<"\n";**
**Â    f.close();**
}

void loadVehiclesCSV(const char* fname) {
**Â    ifstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    string line; getline(f,line);**
**Â    trucksCount = 0; boatsCount = 0;**
**Â    while(getline(f,line) && (trucksCount < MAX_TRUCKS || boatsCount < MAX_BOATS)) {**
**Â        char type[32]; int id,node,capacity,speed,available,load;**
**Â        char buf[512]; strncpy(buf,line.c_str(),511); buf[511]=0;**
**Â        if (sscanf(buf,"%31[^,],%d,%d,%d,%d,%d,%d",type,&id,&node,&capacity,&speed,&available,&load) >= 7) {**
**Â            if (strcmp(type,"truck")==0 && trucksCount < MAX_TRUCKS) {**
**Â                addTruck(id,node,capacity,speed); trucks[trucksCount-1].c.available = (available!=0); trucks[trucksCount-1].c.load = load;**
**Â            } else if (strcmp(type,"boat")==0 && boatsCount < MAX_BOATS) {**
**Â                addBoat(id,node,capacity,speed); boats[boatsCount-1].c.available = (available!=0); boats[boatsCount-1].c.load = load;**
**Â            }**
**Â        }**
**Â    }**
**Â    f.close();**
}

void saveFactoriesCSV(const char* fname) {
**Â    ofstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    f<<"id,name,node,capacityIn,storedRaw,producedUnits,handlesSea\n";**
**Â    for (int i=0;i<factoriesCount;i++) {**
**Â        f<<factories[i].id<<","<<factories[i].name<<","<<factories[i].node<<","<<factories[i].capacityIn<<","<<factories[i].storedRaw<<","<<factories[i].producedUnits<<","<<factories[i].handlesSea<<"\n";**
**Â    }**
**Â    f.close();**
}

void loadFactoriesCSV(const char* fname) {
**Â    ifstream f(fname);**
**Â    if(!f) { cout<<"Failed to open "<<fname<<"\n"; return; }**
**Â    string line; getline(f,line);**
**Â    factoriesCount = 0;**
**Â    while(getline(f,line) && factoriesCount < MAX_FACTORIES) {**
**Â        char buf[512]; strncpy(buf,line.c_str(),511); buf[511]=0;**
**Â        int id,node,capacityIn,storedRaw,producedUnits,handlesSea;**
**Â        char name[64];**
**Â        if (sscanf(buf,"%d,%63[^,],%d,%d,%d,%d,%d",&id,name,&node,&capacityIn,&storedRaw,&producedUnits,&handlesSea) >= 7) {**
**Â            addFactoryEntry(id,name,node,capacityIn,handlesSea!=0);**
**Â            factories[factoriesCount-1].storedRaw = storedRaw; factories[factoriesCount-1].producedUnits = producedUnits;**
**Â        }**
**Â    }**
**Â    f.close();**
}
`
  },
  parking: {
  title: 'Smart Parking System for Commercial & Entertainment Zones',
  desc: `
    <h3>Problem Statement</h3>
    <p>Parking congestion around malls and theatres leads to traffic jams, wasted fuel, and poor user experience.</p>

    <h3>System Approach</h3>
    <p>Parking slots are stored in AVL Trees, VIP/EV vehicles are prioritized using Max-Heaps, and Dijkstra finds the nearest available slot.</p>

    <h3>Algorithms Used</h3>
    <p>AVL Tree, Max Heap, Dijkstra, Merge Sort</p>

    <h3>ğŸ…¿ Smart Parking System (Commercial & Entertainment Zones)</h3>
    <ul>
      <li><b>Parking Slot Registry:</b> AVL Tree â€“ O(log n) insert/search for reserved and EV slots</li>
      <li><b>VIP / Special Queue:</b> Max Heap â€“ priority for VIP and EV vehicles</li>
      <li><b>Shortest Path Routing:</b> Dijkstra (Adjacency Matrix) â€“ nearest available slot selection</li>
      <li><b>Reports & Billing:</b> Merge Sort â€“ occupancy and revenue-based reports</li>
      <li><b>Sensor Alerts:</b> Slot flags â€“ block over-occupied or unavailable slots</li>
      <li><b>EV Handling:</b> Slot attributes â€“ ensures correct zone assignment</li>
      <li><b>Time-Based Billing:</b> Revenue = time Ã— rate â€“ per-vehicle tracking</li>
    </ul>

    <p><b>SDGs:</b> SDG-11, SDG-7, SDG-9</p>
  `,
    code:`#include <bits/stdc++.h>
using namespace std;
const int MAX_SLOTS=200, MAX_CARS=300, MAX_NODES=50, INF=1000000000;

// ----------------- Parking Slot & AVL Tree -----------------
struct ParkingSlot{
    **\*\*int id, zone; bool occupied; bool vip; bool ev; bool coldchain;\*\*

    \*\*int reservedFor; // -1 if free\*\*

    \*\*int sensor; // 1 if sensor detects blockage/occupied\*\*

    \*\*int timeIn; // time in hours\*\***



};

struct AVLNode{
    **\*\*ParkingSlot slot;\*\*

    \*\*AVLNode \\\*left,\\\*right;\*\*

    \*\*int height;\*\*

    \*\*AVLNode(ParkingSlot s): slot(s), left(NULL), right(NULL), height(1){}\*\***



};

int avlHeight(AVLNode* n){ return n?n->height:0;}
int avlBalance(AVLNode* n){ return n?avlHeight(n->left)-avlHeight(n->right):0;}
AVLNode* rightRotate(AVLNode* y){ AVLNode* x=y->left; AVLNode* T2=x->right; x->right=y; y->left=T2; y->height=1+max(avlHeight(y->left),avlHeight(y->right)); x->height=1+max(avlHeight(x->left),avlHeight(x->right)); return x;}
AVLNode* leftRotate(AVLNode* x){ AVLNode* y=x->right; AVLNode* T2=y->left; y->left=x; x->right=T2; x->height=1+max(avlHeight(x->left),avlHeight(x->right)); y->height=1+max(avlHeight(y->left),avlHeight(y->right)); return y;}
AVLNode* avlInsert(AVLNode* node, ParkingSlot s){
    **\*\*if(!node) return new AVLNode(s);\*\*

    \*\*if(s.id<node->slot.id) node->left=avlInsert(node->left,s);\*\*

    \*\*else if(s.id>node->slot.id) node->right=avlInsert(node->right,s);\*\*

    \*\*else return node;\*\*

    \*\*node->height=1+max(avlHeight(node->left),avlHeight(node->right));\*\*

    \*\*int balance=avlBalance(node);\*\*

    \*\*if(balance>1 \\\&\\\& s.id<node->left->slot.id) return rightRotate(node);\*\*

    \*\*if(balance<-1 \\\&\\\& s.id>node->right->slot.id) return leftRotate(node);\*\*

    \*\*if(balance>1 \\\&\\\& s.id>node->left->slot.id){ node->left=leftRotate(node->left); return rightRotate(node);}\*\*

    \*\*if(balance<-1 \\\&\\\& s.id<node->right->slot.id){ node->right=rightRotate(node->right); return leftRotate(node);}\*\*

    \*\*return node;\*\***



}
AVLNode* avlSearch(AVLNode* root,int id){ if(!root) return NULL; if(id==root->slot.id) return root; if(id<root->slot.id) return avlSearch(root->left,id); return avlSearch(root->right,id);}
void avlInorder(AVLNode* root){
    **\*\*if(!root) return;\*\*

    \*\*avlInorder(root->left);\*\*

    \*\*cout<<"Slot "<<root->slot.id<<" Zone "<<root->slot.zone<<" Occ "<<root->slot.occupied<<" VIP "<<root->slot.vip<<" EV "<<root->slot.ev<<" Cold "<<root->slot.coldchain<<" Sensor "<<root->slot.sensor<<"\\\\n";\*\*

    \*\*avlInorder(root->right);\*\***



}

// ----------------- Max Heap for VIP / Special Queue -----------------
struct Car{ int id; bool vip,ev,coldchain; int zonePref; int timeIn; };
Car cars[MAX_CARS]; int carsCount=0;
int vipHeap[MAX_CARS], vipHeapSize=0;

void vipPush(int idx){
    **\*\*vipHeap\\\[vipHeapSize]=idx; int i=vipHeapSize++;\*\*

    \*\*while(i!=0){\*\*

        \*\*int p=(i-1)/2;\*\*

        \*\*if(cars\\\[vipHeap\\\[i]].vip \\\&\\\& !cars\\\[vipHeap\\\[p]].vip){ swap(vipHeap\\\[i],vipHeap\\\[p]); i=p;}\*\*

        \*\*else break;\*\*

    \*\*}\*\***



}
int vipPop(){
    **\*\*if(vipHeapSize==0) return -1;\*\*

    \*\*int root=vipHeap\\\[0]; vipHeap\\\[0]=vipHeap\\\[--vipHeapSize];\*\*

    \*\*int i=0;\*\*

    \*\*while(true){\*\*

        \*\*int l=2\\\*i+1,r=2\\\*i+2,largest=i;\*\*

        \*\*if(l<vipHeapSize \\\&\\\& cars\\\[vipHeap\\\[l]].vip \\\&\\\& !cars\\\[vipHeap\\\[largest]].vip) largest=l;\*\*

        \*\*if(r<vipHeapSize \\\&\\\& cars\\\[vipHeap\\\[r]].vip \\\&\\\& !cars\\\[vipHeap\\\[largest]].vip) largest=r;\*\*

        \*\*if(largest!=i){ swap(vipHeap\\\[i],vipHeap\\\[largest]); i=largest;}\*\*

        \*\*else break;\*\*

    \*\*}\*\*

    \*\*return root;\*\***



}

// ----------------- Parking Graph + Dijkstra -----------------
int adj[MAX_NODES][MAX_NODES]; int nodesCount=0;
void initGraph(int n){ nodesCount=n; for(int i=0;i<n;i++) for(int j=0;j<n;j++) adj[i][j]=(i==j?0:INF);}
void addEdge(int u,int v,int w){ adj[u][v]=w; adj[v][u]=w;}
struct DRes{ int dist[MAX_NODES]; int parent[MAX_NODES]; };
DRes dijkstra(int src){
    **\*\*DRes R; bool used\\\[MAX\\\_NODES]; for(int i=0;i<nodesCount;i++){ R.dist\\\[i]=INF; R.parent\\\[i]=-1; used\\\[i]=false;}\*\*

    \*\*R.dist\\\[src]=0;\*\*

    \*\*for(int iter=0;iter<nodesCount;iter++){\*\*

        \*\*int u=-1,best=INF;\*\*

        \*\*for(int i=0;i<nodesCount;i++) if(!used\\\[i] \\\&\\\& R.dist\\\[i]<best){ best=R.dist\\\[i]; u=i;}\*\*

        \*\*if(u==-1) break;\*\*

        \*\*used\\\[u]=true;\*\*

        \*\*for(int v=0;v<nodesCount;v++) if(adj\\\[u]\\\[v]<INF \\\&\\\& R.dist\\\[u]+adj\\\[u]\\\[v]<R.dist\\\[v]){\*\*

            \*\*R.dist\\\[v]=R.dist\\\[u]+adj\\\[u]\\\[v]; R.parent\\\[v]=u;\*\*

        \*\*}\*\*

    \*\*}\*\*

    \*\*return R;\*\***



}

// ----------------- Merge Sort for Reports -----------------
struct Report{ int slotID; int occupancy; int revenue; };
Report reports[MAX_SLOTS]; int reportSize=0;
void mergeReport(int l,int m,int r){
    **\*\*int n1=m-l+1,n2=r-m; Report \\\*L=new Report\\\[n1]; Report \\\*R=new Report\\\[n2];\*\*

    \*\*for(int i=0;i<n1;i++) L\\\[i]=reports\\\[l+i]; for(int j=0;j<n2;j++) R\\\[j]=reports\\\[m+1+j];\*\*

    \*\*int i=0,j=0,k=l;\*\*

    \*\*while(i<n1 \\\&\\\& j<n2){ if(L\\\[i].occupancy>=R\\\[j].occupancy) reports\\\[k++]=L\\\[i++]; else reports\\\[k++]=R\\\[j++];}\*\*

    \*\*while(i<n1) reports\\\[k++]=L\\\[i++]; while(j<n2) reports\\\[k++]=R\\\[j++]; delete\\\[] L; delete\\\[] R;\*\***



}
void mergeSortReport(int l,int r){ if(l<r){ int m=(l+r)/2; mergeSortReport(l,m); mergeSortReport(m+1,r); mergeReport(l,m,r);}}

// ----------------- Simulation -----------------
AVLNode* parkingRoot=NULL;
void addSlot(int id,int zone,bool vip=false,bool ev=false,bool cold=false){ ParkingSlot s={id,zone,false,vip,ev,cold,-1,0,0}; parkingRoot=avlInsert(parkingRoot,s);}
void addCar(int id,bool vip,bool ev,bool cold,int zonePref,int timeIn){ cars[carsCount]={id,vip,ev,cold,zonePref,timeIn}; vipPush(carsCount); carsCount++; }

void simulateParking(){
    **\*\*cout<<"-- Parking Slots --\\\\n"; avlInorder(parkingRoot);\*\*

    \*\*cout<<"\\\\n-- Dispatching Cars (VIP priority first) --\\\\n";\*\*

    \*\*int idx=vipPop();\*\*

    \*\*while(idx!=-1){\*\*

        \*\*Car \\\&c=cars\\\[idx];\*\*

        \*\*cout<<"Car "<<c.id<<" VIP "<<c.vip<<" EV "<<c.ev<<" Cold "<<c.coldchain<<" looking for slot in zone "<<c.zonePref<<"\\\\n";\*\*

        \*\*AVLNode\\\* slot=NULL; queue<AVLNode\\\*> q; if(parkingRoot) q.push(parkingRoot);\*\*

        \*\*while(!q.empty()){\*\*

            \*\*AVLNode\\\* n=q.front(); q.pop();\*\*

            \*\*if(!n->slot.occupied \\\&\\\& n->slot.zone==c.zonePref \\\&\\\& n->slot.sensor==0 \\\&\\\&\*\* 

               \*\*(!c.ev || n->slot.ev) \\\&\\\& (!c.coldchain || n->slot.coldchain)){ slot=n; break;}\*\*

            \*\*if(n->left) q.push(n->left); if(n->right) q.push(n->right);\*\*

        \*\*}\*\*

        \*\*if(slot){ slot->slot.occupied=true; slot->slot.reservedFor=c.id; slot->slot.timeIn=c.timeIn; cout<<"Assigned Slot "<<slot->slot.id<<"\\\\n";\*\*

            \*\*reports\\\[reportSize++]={slot->slot.id,1, c.timeIn\\\*10};}\*\*

        \*\*else cout<<"No slot available for Car "<<c.id<<"\\\\n";\*\*

        \*\*idx=vipPop();\*\*

    \*\*}\*\*

    \*\*mergeSortReport(0,reportSize-1);\*\*

    \*\*cout<<"\\\\n-- Parking Report --\\\\n";\*\*

    \*\*for(int i=0;i<reportSize;i++) cout<<"Slot "<<reports\\\[i].slotID<<" Occ "<<reports\\\[i].occupancy<<" Revenue $"<<reports\\\[i].revenue<<"\\\\n";\*\***



}

int main(){
    **\*\*cout<<"=== Real-Time Smart Parking System ===\\\\n";\*\*

    \*\*addSlot(1,1,true,true,false); addSlot(2,1,false,false,false); addSlot(3,2,false,false,true); addSlot(4,2,true,false,false);\*\*

    \*\*addSlot(5,3,false,true,false);\*\*

    \*\*addCar(101,true,true,false,1,2); addCar(102,false,false,true,2,1); addCar(103,true,false,true,3,3);\*\*

    \*\*addCar(104,false,false,false,1,1);\*\*

    \*\*simulateParking();\*\*

    \*\*return 0;\*\***



}

`
  },
  energy: {
  title: 'Renewable Energy Grid Management (Solar + Wind)',
  desc: `
    <h3>Problem Statement</h3>
    <p>Renewable energy sources are intermittent, causing instability in urban power supply.</p>

    <h3>System Approach</h3>
    <p>Max-Heaps select highest-producing plants, Min-Heaps detect underperforming units, and Dijkstra routes power with minimal loss.</p>

    <h3>Algorithms Used</h3>
    <p>Max Heap, Min Heap, Dijkstra, Bellmanâ€“Ford, Merge Sort, AVL Tree</p>

    <h3>â˜€ Renewable Energy Grid Management (Solar + Wind)</h3>
    <ul>
      <li><b>Power Plant Priority:</b> Max Heap â€“ selects highest-producing solar/wind plant first</li>
      <li><b>Production Logs:</b> Min Heap â€“ identifies lowest-output plants for maintenance scheduling</li>
      <li><b>Load Distribution:</b> Dijkstra for shortest-loss routing; Bellmanâ€“Ford for penalty/toll adjustments</li>
      <li><b>Daily Generation Sorting:</b> Merge Sort â€“ efficient reporting of energy records</li>
      <li><b>Plant Registry:</b> AVL Tree â€“ O(log n) search, update, and fault detection</li>
    </ul>

    <p><b>SDGs:</b> SDGâ€‘7, SDGâ€‘13, SDGâ€‘9</p>
  `,

    code:`#include <iostream>
#include <climits>
#include <cstring>
using namespace std;

/*************************************************************
**Â * 1. AVL TREE FOR SOLAR + WIND PLANT REGISTRY**
**Â *************************************************************/**
class Plant {
public:
**Â    char name[30];**
**Â    int capacity;     // kW**
**Â    Plant *left, *right;**
**Â    int height;**

**Â    Plant(const char* n, int c) {**
**Â        strcpy(name, n);**
**Â        capacity = c;**
**Â        left = right = NULL;**
**Â        height = 1;**
**Â    }**
};

int height(Plant* n) {
**Â    return n ? n->height : 0;**
}

int balanceFactor(Plant* n) {
**Â    return n ? height(n->left) - height(n->right) : 0;**
}

Plant* rightRotate(Plant* y) {
**Â    Plant* x = y->left;**
**Â    Plant* T = x->right;**

**Â    x->right = y;**
**Â    y->left = T;**

**Â    y->height = max(height(y->left), height(y->right)) + 1;**
**Â    x->height = max(height(x->left), height(x->right)) + 1;**

**Â    return x;**
}

Plant* leftRotate(Plant* x) {
**Â    Plant* y = x->right;**
**Â    Plant* T = y->left;**

**Â    y->left = x;**
**Â    x->right = T;**

**Â    x->height = max(height(x->left), height(x->right)) + 1;**
**Â    y->height = max(height(y->left), height(y->right)) + 1;**

**Â    return y;**
}

Plant* insertPlant(Plant* node, const char* name, int cap) {
**Â    if (!node)**
**Â        return new Plant(name, cap);**

**Â    if (strcmp(name, node->name) < 0)**
**Â        node->left = insertPlant(node->left, name, cap);**
**Â    else**
**Â        node->right = insertPlant(node->right, name, cap);**

**Â    node->height = max(height(node->left), height(node->right)) + 1;**

**Â    int bf = balanceFactor(node);**

**Â    if (bf > 1 && strcmp(name, node->left->name) < 0)**
**Â        return rightRotate(node);**

**Â    if (bf < -1 && strcmp(name, node->right->name) > 0)**
**Â        return leftRotate(node);**

**Â    if (bf > 1 && strcmp(name, node->left->name) > 0) {**
**Â        node->left = leftRotate(node->left);**
**Â        return rightRotate(node);**
**Â    }**

**Â    if (bf < -1 && strcmp(name, node->right->name) < 0) {**
**Â        node->right = rightRotate(node->right);**
**Â        return leftRotate(node);**
**Â    }**

**Â    return node;**
}

void inorder(Plant* root) {
**Â    if (!root) return;**
**Â    inorder(root->left);**
**Â    cout << root->name << " (" << root->capacity << " kW)\n";**
**Â    inorder(root->right);**
}


/*************************************************************
**Â * 2. MAX HEAP FOR PRIORITY (HIGHEST POWER PRODUCING PLANT)**
**Â *************************************************************/**
class MaxHeap {
public:
**Â    int arr[50];**
**Â    int size;**

**Â    MaxHeap() { size = 0; }**

**Â    void insert(int power) {**
**Â        arr[++size] = power;**
**Â        int i = size;**

**Â        while (i > 1 && arr[i/2] < arr[i]) {**
**Â            int t = arr[i];**
**Â            arr[i] = arr[i/2];**
**Â            arr[i/2] = t;**
**Â            i /= 2;**
**Â        }**
**Â    }**

**Â    int extractMax() {**
**Â        if (size == 0) return -1;**

**Â        int maxVal = arr[1];**
**Â        arr[1] = arr[size--];**

**Â        int i = 1;**
**Â        while (true) {**
**Â            int l = 2*i, r = 2*i+1, largest = i;**

**Â            if (l <= size && arr[l] > arr[largest]) largest = l;**
**Â            if (r <= size && arr[r] > arr[largest]) largest = r;**

**Â            if (largest != i) {**
**Â                int t = arr[i];**
**Â                arr[i] = arr[largest];**
**Â                arr[largest] = t;**
**Â                i = largest;**
**Â            } else break;**
**Â        }**
**Â        return maxVal;**
**Â    }**
};


/*************************************************************
**Â * 3. MIN HEAP (LOW PRODUCTION DETECTOR)**
**Â *************************************************************/**
class MinHeap {
public:
**Â    int arr[50];**
**Â    int size;**

**Â    MinHeap() { size = 0; }**

**Â    void insert(int val) {**
**Â        arr[++size] = val;**
**Â        int i = size;**

**Â        while (i > 1 && arr[i/2] > arr[i]) {**
**Â            int t = arr[i];**
**Â            arr[i] = arr[i/2];**
**Â            arr[i/2] = t;**
**Â            i /= 2;**
**Â        }**
**Â    }**

**Â    int extractMin() {**
**Â        if (size == 0) return -1;**
**Â        int minVal = arr[1];**
**Â        arr[1] = arr[size--];**

**Â        int i = 1;**
**Â        while (true) {**
**Â            int l = 2*i, r = 2*i+1, smallest = i;**

**Â            if (l <= size && arr[l] < arr[smallest]) smallest = l;**
**Â            if (r <= size && arr[r] < arr[smallest]) smallest = r;**

**Â            if (smallest != i) {**
**Â                int t = arr[i];**
**Â                arr[i] = arr[smallest];**
**Â                arr[smallest] = t;**
**Â                i = smallest;**
**Â            } else break;**
**Â        }**
**Â        return minVal;**
**Â    }**
};


/*************************************************************
**Â * 4. MERGE SORT (SORT DAILY PRODUCTION)**
**Â *************************************************************/**
void merge(int arr[], int l, int m, int r) {
**Â    int n1 = m-l+1;**
**Â    int n2 = r-m;**

**Â    int L[20], R[20];**

**Â    for (int i=0;i<n1;i++) L[i] = arr[l+i];**
**Â    for (int j=0;j<n2;j++) R[j] = arr[m+1+j];**

**Â    int i=0,j=0,k=l;**

**Â    while(i<n1 && j<n2) {**
**Â        if (L[i] <= R[j]) arr[k++] = L[i++];**
**Â        else arr[k++] = R[j++];**
**Â    }**

**Â    while(i<n1) arr[k++] = L[i++];**
**Â    while(j<n2) arr[k++] = R[j++];**
}

void mergeSort(int arr[], int l, int r) {
**Â    if (l < r) {**
**Â        int m = (l+r)/2;**
**Â        mergeSort(arr, l, m);**
**Â        mergeSort(arr, m+1, r);**
**Â        merge(arr, l, m, r);**
**Â    }**
}


/*************************************************************
**Â * 5. DIJKSTRA (NO VECTORS, ARRAY-BASED) FOR LOAD BALANCING**
**Â *************************************************************/**
int minDist(int dist[], bool used[], int n) {
**Â    int minv = INT_MAX, idx = -1;**
**Â    for (int i=0;i<n;i++)**
**Â        if (!used[i] && dist[i] < minv) {**
**Â            minv = dist[i];**
**Â            idx = i;**
**Â        }**
**Â    return idx;**
}

void dijkstra(int graph[10][10], int src, int n) {
**Â    int dist[10];**
**Â    bool used[10];**

**Â    for (int i=0;i<n;i++) {**
**Â        dist[i] = INT_MAX;**
**Â        used[i] = false;**
**Â    }**

**Â    dist[src] = 0;**

**Â    for (int c=0;c<n-1;c++) {**
**Â        int u = minDist(dist, used, n);**
**Â        used[u] = true;**

**Â        for (int v=0; v<n; v++) {**
**Â            if (!used[v] && graph[u][v] != INT_MAX &&**
**Â                dist[u] + graph[u][v] < dist[v])**
**Â            {**
**Â                dist[v] = dist[u] + graph[u][v];**
**Â            }**
**Â        }**
**Â    }**

**Â    cout << "\nShortest Power Transmission Cost from Plant:\n";**
**Â    for (int i=0;i<n;i++)**
**Â        cout << "City block " << i << " = " << dist[i] << endl;**
}


/*************************************************************
**Â * MAIN PROGRAM**
**Â *************************************************************/**
int main() {

**Â    cout << "\n==== Bellapuram Renewable Energy Grid Management ====\n";**

**Â    /*************** AVL Plant Registry ***************/**
**Â    Plant* root = NULL;**
**Â    root = insertPlant(root, "SolarPlantA", 120);**
**Â    root = insertPlant(root, "WindFarmB", 90);**
**Â    root = insertPlant(root, "SolarPlantC", 150);**

**Â    cout << "\n--- Registered Power Plants (AVL Inorder) ---\n";**
**Â    inorder(root);**


**Â    /*************** Max Heap â€“ Highest Producer ***************/**
**Â    MaxHeap maxH;**
**Â    maxH.insert(120);**
**Â    maxH.insert(90);**
**Â    maxH.insert(150);**

**Â    cout << "\nHighest producing plant (kW): " << maxH.extractMax() << endl;**


**Â    /*************** Min Heap â€“ Low Production Detector ***************/**
**Â    MinHeap minH;**
**Â    minH.insert(10);   // failure**
**Â    minH.insert(25);**
**Â    minH.insert(18);**

**Â    cout << "Lowest production detected (kW): " << minH.extractMin() << endl;**


**Â    /*************** Merge Sort â€“ Sort Day Production ***************/**
**Â    int prod[6] = {50, 120, 80, 60, 140, 30};**
**Â    mergeSort(prod, 0, 5);**

**Â    cout << "\nSorted Daily Production (kW): ";**
**Â    for (int i=0;i<6;i++) cout << prod[i] << " ";**


**Â    /*************** Dijkstra â€“ Load Distribution ***************/**
**Â    int graph[10][10] = {**
**Â        {0,4,INT_MAX,2,INT_MAX},**
**Â        {4,0,3,INT_MAX,INT_MAX},**
**Â        {INT_MAX,3,0,5,6},**
**Â        {2,INT_MAX,5,0,4},**
**Â        {INT_MAX,INT_MAX,6,4,0}**
**Â    };**

**Â    cout << "\n";**
**Â    dijkstra(graph, 0, 5);**


**Â    return 0;**
}
`
  },
  cargo: {
  title: 'Port Cargo Scheduling & Container Allocation',
  desc: `
    <h3>Problem Statement</h3>
    <p>Ports suffer delays due to inefficient container placement and berth scheduling.</p>

    <h3>System Approach</h3>
    <p>Containers are prioritized using Heaps, routes are optimized using graph algorithms, and scheduling minimizes turnaround time.</p>

    <h3>Algorithms Used</h3>
    <p>Max Heap, Min Heap, AVL Tree, Red-Black Tree, Dijkstra, Bellmanâ€“Ford, Kruskal, QuickSort</p>

    <h3>ğŸ“¦ Port Cargo Scheduling & Container Allocation</h3>
    <ul>
      <li><b>Cargo Priority Handling:</b> Max Heap â€“ O(log n) handling of urgent/perishable cargo</li>
      <li><b>Container Storage:</b> AVL Tree â€“ fast O(log n) insert/search of container IDs</li>
      <li><b>Cargo Search Index:</b> Red-Black Tree â€“ efficient shipment lookup & tracking</li>
      <li><b>Manifest Sorting:</b> QuickSort â€“ array-based cargo report generation</li>
      <li><b>Berth Assignment:</b> Min Heap â€“ earliest available berth scheduling</li>
      <li><b>Truck & Cargo Routing:</b> Dijkstra â€“ shortest path from port to warehouse/city</li>
      <li><b>Penalty/Traffic Costs:</b> Bellmanâ€“Ford â€“ adjusts routing for tolls and delays</li>
      <li><b>Network Model:</b> Adjacency Matrix â€“ fixed-size port & city graph</li>
      <li><b>Path Retrieval:</b> Parent Array â€“ reconstruct delivery routes</li>
      <li><b>Logistics Backbone:</b> Kruskal â€“ minimum-cost spanning network for port-city connections</li>
    </ul>

    <p><b>SDGs:</b> SDGâ€‘8, SDGâ€‘9, SDGâ€‘12</p>
  `,

    code:`#include <iostream>
#include <string>
#include <climits>
#include <algorithm>
using namespace std;

const int NODES = 5;
const int INF = 1000000000; // large

///////////////////////////
// === MAX HEAP (custom) ===
///////////////////////////
class MaxHeap {
**Â    int *arr;**
**Â    int capacity;**
**Â    int size;**
public:
**Â    MaxHeap(int cap=1000) {**
**Â        capacity = cap;**
**Â        size = 0;**
**Â        arr = new int[capacity];**
**Â    }**
**Â    ~MaxHeap(){ delete[] arr; }**
**Â    bool empty() const { return size==0; }**
**Â    void insert(int val) {**
**Â        if (size == capacity) {**
**Â            int *narr = new int[capacity*2];**
**Â            for (int i=0;i<size;i++) narr[i]=arr[i];**
**Â            delete[] arr;**
**Â            arr = narr;**
**Â            capacity *= 2;**
**Â        }**
**Â        int i = size++;**
**Â        arr[i] = val;**
**Â        while (i != 0 && arr[(i-1)/2] < arr[i]) {**
**Â            std::swap(arr[i], arr[(i-1)/2]);**
**Â            i = (i-1)/2;**
**Â        }**
**Â    }**
**Â    int extractMax() {**
**Â        if (size <= 0) return -1;**
**Â        int root = arr[0];**
**Â        arr[0] = arr[size-1];**
**Â        size--;**
**Â        heapify(0);**
**Â        return root;**
**Â    }**
**Â    void heapify(int i) {**
**Â        int largest = i;**
**Â        int l = 2*i + 1, r = 2*i + 2;**
**Â        if (l < size && arr[l] > arr[largest]) largest = l;**
**Â        if (r < size && arr[r] > arr[largest]) largest = r;**
**Â        if (largest != i) {**
**Â            std::swap(arr[i], arr[largest]);**
**Â            heapify(largest);**
**Â        }**
**Â    }**
**Â    void display() const {**
**Â        for (int i=0;i<size;i++) cout << arr[i] << " ";**
**Â        cout << endl;**
**Â    }**
};

///////////////////////////
// === AVL TREE (container storage) ===
///////////////////////////
struct AVLNode {
**Â    int key; // container ID**
**Â    AVLNode *left, *right;**
**Â    int height;**
**Â    AVLNode(int k): key(k), left(nullptr), right(nullptr), height(1) {}**
};
int avlHeight(AVLNode* n) { return n ? n->height : 0; }
int avlBalance(AVLNode* n) { return n ? avlHeight(n->left) - avlHeight(n->right) : 0; }
AVLNode* avlRightRotate(AVLNode* y){
**Â    AVLNode* x = y->left;**
**Â    AVLNode* T2 = x->right;**
**Â    x->right = y; y->left = T2;**
**Â    y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));**
**Â    x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));**
**Â    return x;**
}
AVLNode* avlLeftRotate(AVLNode* x){
**Â    AVLNode* y = x->right;**
**Â    AVLNode* T2 = y->left;**
**Â    y->left = x; x->right = T2;**
**Â    x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));**
**Â    y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));**
**Â    return y;**
}
AVLNode* avlInsert(AVLNode* node, int key) {
**Â    if (!node) return new AVLNode(key);**
**Â    if (key < node->key) node->left = avlInsert(node->left, key);**
**Â    else if (key > node->key) node->right = avlInsert(node->right, key);**
**Â    else return node;**
**Â    node->height = 1 + max(avlHeight(node->left), avlHeight(node->right));**
**Â    int balance = avlBalance(node);**
**Â    if (balance > 1 && key < node->left->key) return avlRightRotate(node);**
**Â    if (balance < -1 && key > node->right->key) return avlLeftRotate(node);**
**Â    if (balance > 1 && key > node->left->key) {**
**Â        node->left = avlLeftRotate(node->left);**
**Â        return avlRightRotate(node);**
**Â    }**
**Â    if (balance < -1 && key < node->right->key) {**
**Â        node->right = avlRightRotate(node->right);**
**Â        return avlLeftRotate(node);**
**Â    }**
**Â    return node;**
}
void avlInorder(AVLNode* root) {
**Â    if (!root) return;**
**Â    avlInorder(root->left);**
**Â    cout << root->key << " ";**
**Â    avlInorder(root->right);**
}

///////////////////////////
// === RED-BLACK TREE (cargo search) ===
///////////////////////////
enum Color { RED, BLACK };
struct RBNode {
**Â    int key;**
**Â    Color color;**
**Â    RBNode *left, *right, *parent;**
**Â    RBNode(int k): key(k), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}**
};
class RBTree {
public:
**Â    RBNode* root;**
**Â    RBTree(): root(nullptr) {}**
**Â    RBNode* bstInsert(RBNode* root, RBNode* pt) {**
**Â        if (!root) return pt;**
**Â        if (pt->key < root->key) {**
**Â            root->left = bstInsert(root->left, pt);**
**Â            root->left->parent = root;**
**Â        } else if (pt->key > root->key) {**
**Â            root->right = bstInsert(root->right, pt);**
**Â            root->right->parent = root;**
**Â        }**
**Â        return root;**
**Â    }**
**Â    void rotateLeft(RBNode* &root, RBNode* &pt) {**
**Â        RBNode* pt_right = pt->right;**
**Â        pt->right = pt_right->left;**
**Â        if (pt->right) pt->right->parent = pt;**
**Â        pt_right->parent = pt->parent;**
**Â        if (!pt->parent) root = pt_right;**
**Â        else if (pt == pt->parent->left) pt->parent->left = pt_right;**
**Â        else pt->parent->right = pt_right;**
**Â        pt_right->left = pt;**
**Â        pt->parent = pt_right;**
**Â    }**
**Â    void rotateRight(RBNode* &root, RBNode* &pt) {**
**Â        RBNode* pt_left = pt->left;**
**Â        pt->left = pt_left->right;**
**Â        if (pt->left) pt->left->parent = pt;**
**Â        pt_left->parent = pt->parent;**
**Â        if (!pt->parent) root = pt_left;**
**Â        else if (pt == pt->parent->left) pt->parent->left = pt_left;**
**Â        else pt->parent->right = pt_left;**
**Â        pt_left->right = pt;**
**Â        pt->parent = pt_left;**
**Â    }**
**Â    void fixViolation(RBNode* &root, RBNode* &pt) {**
**Â        RBNode *parent_pt = nullptr, *grand_parent_pt = nullptr;**
**Â        while ((pt != root) && (pt->color == RED) && (pt->parent->color == RED)) {**
**Â            parent_pt = pt->parent;**
**Â            grand_parent_pt = pt->parent->parent;**
**Â            if (parent_pt == grand_parent_pt->left) {**
**Â                RBNode *uncle_pt = grand_parent_pt->right;**
**Â                if (uncle_pt && uncle_pt->color == RED) {**
**Â                    grand_parent_pt->color = RED;**
**Â                    parent_pt->color = BLACK;**
**Â                    uncle_pt->color = BLACK;**
**Â                    pt = grand_parent_pt;**
**Â                } else {**
**Â                    if (pt == parent_pt->right) {**
**Â                        rotateLeft(root, parent_pt);**
**Â                        pt = parent_pt;**
**Â                        parent_pt = pt->parent;**
**Â                    }**
**Â                    rotateRight(root, grand_parent_pt);**
**Â                    swap(parent_pt->color, grand_parent_pt->color);**
**Â                    pt = parent_pt;**
**Â                }**
**Â            } else {**
**Â                RBNode *uncle_pt = grand_parent_pt->left;**
**Â                if (uncle_pt && uncle_pt->color == RED) {**
**Â                    grand_parent_pt->color = RED;**
**Â                    parent_pt->color = BLACK;**
**Â                    uncle_pt->color = BLACK;**
**Â                    pt = grand_parent_pt;**
**Â                } else {**
**Â                    if (pt == parent_pt->left) {**
**Â                        rotateRight(root, parent_pt);**
**Â                        pt = parent_pt;**
**Â                        parent_pt = pt->parent;**
**Â                    }**
**Â                    rotateLeft(root, grand_parent_pt);**
**Â                    swap(parent_pt->color, grand_parent_pt->color);**
**Â                    pt = parent_pt;**
**Â                }**
**Â            }**
**Â        }**
**Â        root->color = BLACK;**
**Â    }**
**Â    void insert(int key) {**
**Â        RBNode* pt = new RBNode(key);**
**Â        root = bstInsert(root, pt);**
**Â        fixViolation(root, pt);**
**Â    }**
**Â    void inorder(RBNode* node) {**
**Â        if (!node) return;**
**Â        inorder(node->left);**
**Â        cout << node->key << " ";**
**Â        inorder(node->right);**
**Â    }**
**Â    RBNode* search(int key) {**
**Â        RBNode* cur = root;**
**Â        while (cur) {**
**Â            if (key == cur->key) return cur;**
**Â            if (key < cur->key) cur = cur->left;**
**Â            else cur = cur->right;**
**Â        }**
**Â        return nullptr;**
**Â    }**
};

///////////////////////////
// === Manifest array & QuickSort ===
///////////////////////////
struct ManifestItem {
**Â    int id;**
**Â    string desc;**
};
const int MANIFEST_CAP = 100;
ManifestItem manifest[MANIFEST_CAP];
int manifestSize = 0;

void quickSortManifest(int left, int right) {
**Â    if (left >= right) return;**
**Â    int pivot = manifest[(left+right)/2].id;**
**Â    int i = left, j = right;**
**Â    while (i <= j) {**
**Â        while (manifest[i].id < pivot) i++;**
**Â        while (manifest[j].id > pivot) j--;**
**Â        if (i <= j) {**
**Â            swap(manifest[i], manifest[j]);**
**Â            i++; j--;**
**Â        }**
**Â    }**
**Â    if (left < j) quickSortManifest(left, j);**
**Â    if (i < right) quickSortManifest(i, right);**
}

///////////////////////////
// === Graph (adjacency matrix) + Dijkstra (custom min-heap) ===
///////////////////////////
int graphMat[NODES][NODES];

struct PQNode { int dist; int node; };
const int PQ_CAP = 200;
struct MinHeapPQ {
**Â    PQNode arr[PQ_CAP];**
**Â    int size;**
**Â    MinHeapPQ(): size(0) {}**
**Â    bool empty() const { return size==0; }**
**Â    void push(int d, int u) {**
**Â        if (size >= PQ_CAP) return;**
**Â        int i = size++;**
**Â        arr[i].dist = d; arr[i].node = u;**
**Â        while (i != 0) {**
**Â            int p = (i-1)/2;**
**Â            if (arr[p].dist <= arr[i].dist) break;**
**Â            swap(arr[p], arr[i]);**
**Â            i = p;**
**Â        }**
**Â    }**
**Â    PQNode pop() {**
**Â        PQNode root = arr[0];**
**Â        arr[0] = arr[size-1];**
**Â        size--;**
**Â        int i = 0;**
**Â        while (true) {**
**Â            int l = 2*i+1, r = 2*i+2, smallest = i;**
**Â            if (l < size && arr[l].dist < arr[smallest].dist) smallest = l;**
**Â            if (r < size && arr[r].dist < arr[smallest].dist) smallest = r;**
**Â            if (smallest == i) break;**
**Â            swap(arr[i], arr[smallest]);**
**Â            i = smallest;**
**Â        }**
**Â        return root;**
**Â    }**
};

void dijkstraNoVector(int src, int distArr[], int parentArr[]) {
**Â    for (int i=0;i<NODES;i++) { distArr[i] = INF; parentArr[i] = -1; }**
**Â    distArr[src] = 0;**
**Â    MinHeapPQ pq;**
**Â    pq.push(0, src);**
**Â    while (!pq.empty()) {**
**Â        PQNode p = pq.pop();**
**Â        int d = p.dist, u = p.node;**
**Â        if (d != distArr[u]) continue; // stale**
**Â        for (int v=0; v<NODES; v++) {**
**Â            if (graphMat[u][v] < INF) {**
**Â                int nd = d + graphMat[u][v];**
**Â                if (nd < distArr[v]) {**
**Â                    distArr[v] = nd;**
**Â                    parentArr[v] = u;**
**Â                    pq.push(nd, v);**
**Â                }**
**Â            }**
**Â        }**
**Â    }**
}

void retrievePathNoVector(int target, int parentArr[], int outPath[], int &outLen) {
**Â    // outPath max length NODES**
**Â    outLen = 0;**
**Â    int cur = target;**
**Â    int temp[NODES];**
**Â    int tlen = 0;**
**Â    while (cur != -1) {**
**Â        temp[tlen++] = cur;**
**Â        cur = parentArr[cur];**
**Â    }**
**Â    // reverse**
**Â    for (int i = tlen-1; i>=0; --i) outPath[outLen++] = temp[i];**
}

///////////////////////////
// === Berth pool (min-heap by nextAvailable) ===
///////////////////////////
struct Berth {
**Â    string name;**
**Â    int nextAvailable;**
};
const int BERTH_CAP = 20;
struct BerthHeap {
**Â    Berth arr[BERTH_CAP];**
**Â    int size;**
**Â    BerthHeap(): size(0) {}**
**Â    bool empty() const { return size==0; }**
**Â    void push(const Berth &b) {**
**Â        if (size >= BERTH_CAP) return;**
**Â        int i = size++;**
**Â        arr[i] = b;**
**Â        while (i != 0) {**
**Â            int p = (i-1)/2;**
**Â            if (arr[p].nextAvailable <= arr[i].nextAvailable) break;**
**Â            swap(arr[p], arr[i]);**
**Â            i = p;**
**Â        }**
**Â    }**
**Â    Berth pop() {**
**Â        Berth root = arr[0];**
**Â        arr[0] = arr[size-1];**
**Â        size--;**
**Â        int i = 0;**
**Â        while (true) {**
**Â            int l = 2*i+1, r = 2*i+2, smallest = i;**
**Â            if (l < size && arr[l].nextAvailable < arr[smallest].nextAvailable) smallest = l;**
**Â            if (r < size && arr[r].nextAvailable < arr[smallest].nextAvailable) smallest = r;**
**Â            if (smallest == i) break;**
**Â            swap(arr[i], arr[smallest]);**
**Â            i = smallest;**
**Â        }**
**Â        return root;**
**Â    }**
**Â    // for dumping state without destroying heap**
**Â    void dumpState() {**
**Â        for (int i=0;i<size;i++) cout << arr[i].name << " nextAvailable=" << arr[i].nextAvailable << "\n";**
**Â    }**
};

///////////////////////////
// === SIMULATION / MAIN ===
///////////////////////////
int main() {
**Â    ios::sync_with_stdio(false);**
**Â    cin.tie(nullptr);**

**Â    cout << "=== Bellapuram Smart Cargo Management System (NO vector) ===\n\n";**

**Â    // 1) Prepare structures**
**Â    MaxHeap cargoPriorityHeap(50);**
**Â    AVLNode* containerStorage = nullptr;**
**Â    RBTree cargoSearchIndex;**

**Â    // 2) Manifest populate (array)**
**Â    manifestSize = 0;**
**Â    manifest[manifestSize++] = {3001, "Electronics - 20 pallets"};**
**Â    manifest[manifestSize++] = {1002, "Perishable Food - 10 pallets"};**
**Â    manifest[manifestSize++] = {2005, "Medical Supplies - 5 pallets"};**
**Â    manifest[manifestSize++] = {4003, "Automobile Parts - 15 pallets"};**

**Â    // 3) Port graph (adjacency matrix)**
**Â    for (int i=0;i<NODES;i++) for (int j=0;j<NODES;j++) graphMat[i][j] = INF;**
**Â    // diagonal 0**
**Â    for (int i=0;i<NODES;i++) graphMat[i][i] = 0;**
**Â    // edges (same as previous)**
**Â    graphMat[0][1] = 10; graphMat[0][2] = 5;**
**Â    graphMat[1][2] = 2;  graphMat[1][3] = 20; // keep 20 to reflect earlier 20**
**Â    graphMat[2][1] = 3;  graphMat[2][3] = 9; graphMat[2][4] = 2;**
**Â    graphMat[3][4] = 4;**
**Â    graphMat[4][3] = 6;  graphMat[4][0] = 30;**

**Â    // 4) Berth pool (min-heap)**
**Â    BerthHeap berthPool;**
**Â    berthPool.push({"Berth-A", 0});**
**Â    berthPool.push({"Berth-B", 0});**
**Â    berthPool.push({"Berth-C", 2});**

**Â    // --- Simulation actions ---**

**Â    cout << "--- Step 1: Insert cargo into priority heap, AVL, RB index ---\n";**
**Â    cargoPriorityHeap.insert(2005); cargoPriorityHeap.insert(1002);**
**Â    cargoPriorityHeap.insert(3001); cargoPriorityHeap.insert(4003);**

**Â    containerStorage = avlInsert(containerStorage, 5001);**
**Â    containerStorage = avlInsert(containerStorage, 3002);**
**Â    containerStorage = avlInsert(containerStorage, 7007);**

**Â    cargoSearchIndex.insert(5001); cargoSearchIndex.insert(3002); cargoSearchIndex.insert(7007);**

**Â    cout << "Cargo Priority Heap contents (array order): ";**
**Â    cargoPriorityHeap.display();**

**Â    cout << "\nContainer Storage (AVL inorder): ";**
**Â    avlInorder(containerStorage);**
**Â    cout << "\nRB Tree cargo index (inorder): ";**
**Â    cargoSearchIndex.inorder(cargoSearchIndex.root);**
**Â    cout << "\n\n";**

**Â    cout << "--- Step 2: Sort manifest (QuickSort) ---\n";**
**Â    cout << "Manifest before sort (id : desc):\n";**
**Â    for (int i=0;i<manifestSize;i++) cout << manifest[i].id << " : " << manifest[i].desc << "\n";**
**Â    quickSortManifest(0, manifestSize-1);**
**Â    cout << "\nManifest after QuickSort (by id ascending):\n";**
**Â    for (int i=0;i<manifestSize;i++) cout << manifest[i].id << " : " << manifest[i].desc << "\n";**

**Â    cout << "\n--- Step 3: Assign earliest available berth and schedule truck route ---\n";**
**Â    int topCargo = cargoPriorityHeap.extractMax();**
**Â    cout << "Top priority cargo ID to dispatch: " << topCargo << "\n";**

**Â    if (!berthPool.empty()) {**
**Â        Berth b = berthPool.pop();**
**Â        int arrivalTime = 1;**
**Â        int startTime = max(arrivalTime, b.nextAvailable);**
**Â        cout << "Assigning " << b.name << " starting at time " << startTime << "\n";**
**Â        b.nextAvailable = startTime + 3;**
**Â        berthPool.push(b);**
**Â    } else {**
**Â        cout << "No berth available right now. Queueing...\n";**
**Â    }**

**Â    // Dijkstra (no vector)**
**Â    int distArr[NODES], parentArr[NODES];**
**Â    dijkstraNoVector(0, distArr, parentArr);**

**Â    cout << "\nDijkstra distances from port:\n";**
**Â    for (int i=0;i<NODES;i++) {**
**Â        if (distArr[i] >= INF) cout << "Node " << i << " dist = -1\n";**
**Â        else cout << "Node " << i << " dist = " << distArr[i] << "\n";**
**Â    }**

**Â    int target = (distArr[1] <= distArr[2]) ? 1 : 2;**
**Â    cout << "Chosen warehouse node: " << target << "\n";**
**Â    int path[NODES], pathLen = 0;**
**Â    retrievePathNoVector(target, parentArr, path, pathLen);**
**Â    cout << "Route: ";**
**Â    for (int i=0;i<pathLen;i++) {**
**Â        cout << path[i];**
**Â        if (i+1<pathLen) cout << " -> ";**
**Â    }**
**Â    cout << "\nEstimated travel cost/time: " << (distArr[target] >= INF ? -1 : distArr[target]) << "\n";**

**Â    cout << "\n--- Step 4: Cargo search demo (RB tree) ---\n";**
**Â    int searchID = 3002;**
**Â    RBNode* found = cargoSearchIndex.search(searchID);**
**Â    if (found) cout << "Cargo ID " << searchID << " found in index.\n";**
**Â    else cout << "Cargo ID " << searchID << " NOT found in index.\n";**

**Â    cout << "\n--- Step 5: Final state ---\n";**
**Â    cout << "Berth pool state (nextAvailable times):\n";**
**Â    berthPool.dumpState();**

**Â    cout << "\nRemaining cargo priority heap: ";**
**Â    cargoPriorityHeap.display();**

**Â    cout << "\nContainer Storage (AVL inorder) final: ";**
**Â    avlInorder(containerStorage);**
**Â    cout << "\n";**

**Â    cout << "\nSimulation complete.\n";**
**Â    return 0;**
}
`
  },
  transport: {
  title: 'Public Transport Fleet Optimization',
  desc: `
    <h3>Problem Statement</h3>
    <p>Uneven passenger distribution causes overcrowding on some routes and underutilization on others.</p>

    <h3>System Approach</h3>
    <p>Passenger demand is analyzed, routes are evaluated using BFS/DFS, and fleets are optimized using shortest paths.</p>

    <h3>Algorithms Used</h3>
    <p>BFS, DFS, Dijkstra, Bellmanâ€“Ford, Floydâ€“Warshall</p>

    <h3>ğŸšŒ Public Transport Fleet Optimization</h3>
    <ul>
      <li><b>Shortest Route:</b> Dijkstra â€“ fastest paths with positive travel times</li>
      <li><b>Routes with Penalties:</b> Bellmanâ€“Ford â€“ handles tolls, traffic delays, fines</li>
      <li><b>Network Exploration:</b> BFS / DFS â€“ checks connectivity & reachable zones</li>
      <li><b>All-Pairs Shortest Paths:</b> Floydâ€“Warshall â€“ city-wide route optimization</li>
      <li><b>Graph Representation:</b> Adjacency Matrix â€“ fixed-size city network</li>
      <li><b>Distance Tracking:</b> Arrays â€“ shortest distance & visited tracking</li>
      <li><b>BFS Queue:</b> Array-based Queue â€“ FIFO traversal without vectors</li>
    </ul>

    <p><b>Efficiency:</b> O(VÂ²) Dijkstra, O(VÂ³) Floydâ€“Warshall</p>
    <p><b>SDGs:</b> SDGâ€‘11, SDGâ€‘13, SDGâ€‘9</p>
  `,
    code:`#include <iostream>
#include <climits>
using namespace std;
const int MAX = 10;

// ------------------ DIJKSTRA (NO VECTOR) ------------------
void dijkstra(int graph[MAX][MAX], int n, int src) {
**Â    int dist[MAX];**
**Â    bool visited[MAX];**

**Â    for(int i = 0; i < n; i++) {**
**Â        dist[i] = INT_MAX;**
**Â        visited[i] = false;**
**Â    }**
**Â    dist[src] = 0;**

**Â    for(int count = 0; count < n-1; count++) {**
**Â        int u = -1, minVal = INT_MAX;**
**Â        for(int i = 0; i < n; i++)**
**Â            if(!visited[i] && dist[i] < minVal)**
**Â                minVal = dist[i], u = i;**

**Â        visited[u] = true;**

**Â        for(int v = 0; v < n; v++)**
**Â            if(graph[u][v] != INT_MAX && dist[u] + graph[u][v] < dist[v])**
**Â                dist[v] = dist[u] + graph[u][v];**
**Â    }**

**Â    cout << "\nDijkstra distances from source " << src << ":\n";**
**Â    for(int i = 0; i < n; i++)**
**Â        cout << i << " -> " << dist[i] << endl;**
}

// ------------------ BELLMAN-FORD (NO VECTOR) ------------------
void bellmanFord(int edges[][3], int edgeCount, int V, int src) {
**Â    int dist[MAX];**
**Â    for(int i = 0; i < V; i++) dist[i] = INT_MAX;**
**Â    dist[src] = 0;**

**Â    for(int i = 1; i < V; i++) {**
**Â        for(int j = 0; j < edgeCount; j++) {**
**Â            int u = edges[j][0], v = edges[j][1], w = edges[j][2];**
**Â            if(dist[u] != INT_MAX && dist[u] + w < dist[v])**
**Â                dist[v] = dist[u] + w;**
**Â        }**
**Â    }**

**Â    cout << "\nBellman-Ford distances from " << src << ":\n";**
**Â    for(int i = 0; i < V; i++)**
**Â        cout << i << " -> " << dist[i] << endl;**
}

// ------------------ BFS (NO VECTOR) ------------------
void BFS(int graph[MAX][MAX], int n, int start) {
**Â    bool visited[MAX] = {false};**
**Â    int queue[MAX], front = 0, rear = 0;**

**Â    visited[start] = true;**
**Â    queue[rear++] = start;**

**Â    cout << "\nBFS Traversal: ";**
**Â    while(front < rear) {**
**Â        int u = queue[front++];**

**Â        cout << u << " ";**

**Â        for(int v = 0; v < n; v++) {**
**Â            if(graph[u][v] == 1 && !visited[v]) {**
**Â                visited[v] = true;**
**Â                queue[rear++] = v;**
**Â            }**
**Â        }**
**Â    }**
**Â    cout << endl;**
}

// ------------------ FLOYD-WARSHALL (NO VECTOR) ------------------
void floydWarshall(int dist[MAX][MAX], int V) {
**Â    for(int k = 0; k < V; k++)**
**Â        for(int i = 0; i < V; i++)**
**Â            for(int j = 0; j < V; j++)**
**Â                if(dist[i][k] != INT_MAX && dist[k][j] != INT_MAX)**
**Â                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);**

**Â    cout << "\nFloyd-Warshall APSP Matrix:\n";**
**Â    for(int i = 0; i < V; i++) {**
**Â        for(int j = 0; j < V; j++) {**
**Â            if(dist[i][j] == INT_MAX) cout << "INF ";**
**Â            else cout << dist[i][j] << " ";**
**Â        }**
**Â        cout << endl;**
**Â    }**
}

// ------------------ MAIN ------------------
int main() {
**Â    cout << "=== Bellapuram Transport Routing System (NO VECTORS) ===\n";**

**Â    int n = 5;**
**Â    int graph[MAX][MAX];**

**Â    // Initialize all edges to INF**
**Â    for(int i = 0; i < MAX; i++)**
**Â        for(int j = 0; j < MAX; j++)**
**Â            graph[i][j] = INT_MAX;**

**Â    // Weighted edges**
**Â    graph[0][1] = 10;  graph[0][2] = 5;**
**Â    graph[1][2] = 2;   graph[1][3] = 1;**
**Â    graph[2][1] = 3;   graph[2][3] = 9; graph[2][4] = 2;**
**Â    graph[3][4] = 4;**
**Â    graph[4][3] = 6;   graph[4][0] = 7;**

**Â    dijkstra(graph, n, 0);**

**Â    // BFS UNWEIGHTED GRAPH (for demonstration)**
**Â    int bfsGraph[MAX][MAX] = {0};**
**Â    bfsGraph[0][1] = bfsGraph[0][2] = 1;**
**Â    bfsGraph[1][2] = bfsGraph[1][3] = 1;**
**Â    bfsGraph[2][3] = bfsGraph[3][4] = bfsGraph[4][0] = 1;**

**Â    BFS(bfsGraph, 5, 0);**

**Â    // FLOYD-WARSHALL**
**Â    int fw[MAX][MAX] = {**
**Â        {0,3,8,INT_MAX,-4},**
**Â        {INT_MAX,0,INT_MAX,1,7},**
**Â        {INT_MAX,4,0,INT_MAX,INT_MAX},**
**Â        {2,INT_MAX,-5,0,INT_MAX},**
**Â        {INT_MAX,INT_MAX,INT_MAX,6,0}**
**Â    };**
**Â    floydWarshall(fw, 5);**

**Â    return 0;**
}
`
  },
  water: {
  title: 'Water Distribution System',
  desc: `
    <h3>Problem Statement</h3>
    <p>Water leakage and unequal distribution lead to shortages in many city zones.</p>

    <h3>System Approach</h3>
    <p>Pipelines are modeled as graphs, MST algorithms design efficient networks, and shortest paths reroute water during failures.</p>

    <h3>Algorithms Used</h3>
    <p>Prim, Kruskal, Dijkstra, Bellmanâ€“Ford</p>

    <h3>ğŸ’§ Water Distribution System</h3>
    <ul>
      <li><b>Pipeline Network Design:</b> Prim / Kruskal â€“ minimum spanning tree for efficient pipe layout</li>
      <li><b>Leakage Rerouting:</b> Dijkstra â€“ shortest alternate path to maintain supply during failures</li>
      <li><b>Penalty Routing:</b> Bellmanâ€“Ford â€“ handles extra costs due to leakage, pumping, or pressure loss</li>
      <li><b>Zone Connectivity:</b> BFS / DFS â€“ verify all city zones are reachable</li>
      <li><b>Reservoir Registry:</b> AVL Tree â€“ O(log n) lookup for tanks and reservoirs</li>
      <li><b>Flow Monitoring:</b> Arrays â€“ track distribution volumes and detect imbalances</li>
      <li><b>Report Generation:</b> Merge Sort â€“ stable sorting of daily water usage logs</li>
    </ul>

    <p><b>Efficiency:</b> MST O(E log V), Dijkstra O(VÂ²), Bellmanâ€“Ford O(VÂ·E)</p>
    <p><b>SDGs:</b> SDGâ€‘6, SDGâ€‘11, SDGâ€‘13</p>
  `,
   code:`#include <bits/stdc++.h>
using namespace std;

const int MAX_NODES = 50;       // distribution nodes
const int MAX_EDGES = 200;      // possible pipes
const int MAX_CUSTOMERS = 500;  // registry
const int INF = 1000000000;

// ---------------------- AVL TREE: Customer Registry ----------------------
struct Customer {
**Â    int meterId;          // unique meter id**
**Â    char name[64];**
**Â    int node;             // connected distribution node**
**Â    double avgDaily;      // avg daily consumption**
**Â    Customer() : meterId(0), node(-1), avgDaily(0.0) { name[0]='\0'; }**
};

struct AVLNode {
**Â    Customer cust;**
**Â    AVLNode *left, *right;**
**Â    int height;**
**Â    AVLNode(const Customer &c): cust(c), left(nullptr), right(nullptr), height(1) {}**
};

int heightAVL(AVLNode* n) { return n? n->height : 0; }
AVLNode* rotateRightAVL(AVLNode* y) {
**Â    AVLNode* x = y->left; AVLNode* T2 = x->right;**
**Â    x->right = y; y->left = T2;**
**Â    y->height = max(heightAVL(y->left), heightAVL(y->right)) + 1;**
**Â    x->height = max(heightAVL(x->left), heightAVL(x->right)) + 1;**
**Â    return x;**
}
AVLNode* rotateLeftAVL(AVLNode* x) {
**Â    AVLNode* y = x->right; AVLNode* T2 = y->left;**
**Â    y->left = x; x->right = T2;**
**Â    x->height = max(heightAVL(x->left), heightAVL(x->right)) + 1;**
**Â    y->height = max(heightAVL(y->left), heightAVL(y->right)) + 1;**
**Â    return y;**
}
AVLNode* insertAVL(AVLNode* node, const Customer &c) {
**Â    if(!node) return new AVLNode(c);**
**Â    if(c.meterId < node->cust.meterId) node->left = insertAVL(node->left, c);**
**Â    else if(c.meterId > node->cust.meterId) node->right = insertAVL(node->right, c);**
**Â    else return node; // duplicate**
**Â    node->height = 1 + max(heightAVL(node->left), heightAVL(node->right));**
**Â    int balance = heightAVL(node->left) - heightAVL(node->right);**
**Â    if(balance > 1 && c.meterId < node->left->cust.meterId) return rotateRightAVL(node);**
**Â    if(balance < -1 && c.meterId > node->right->cust.meterId) return rotateLeftAVL(node);**
**Â    if(balance > 1 && c.meterId > node->left->cust.meterId) { node->left = rotateLeftAVL(node->left); return rotateRightAVL(node); }**
**Â    if(balance < -1 && c.meterId < node->right->cust.meterId) { node->right = rotateRightAVL(node->right); return rotateLeftAVL(node); }**
**Â    return node;**
}
AVLNode* searchAVL(AVLNode* root, int meterId) {
**Â    if(!root) return nullptr;**
**Â    if(meterId == root->cust.meterId) return root;**
**Â    if(meterId < root->cust.meterId) return searchAVL(root->left, meterId);**
**Â    return searchAVL(root->right, meterId);**
}

// ---------------------- Heaps: Pump priority & low nodes ----------------------
struct MaxHeap {
**Â    int arr[100]; int size;**
**Â    MaxHeap(): size(0) {}**
**Â    void insert(int val) {**
**Â        arr[size++] = val;**
**Â        int i = size-1;**
**Â        while(i && arr[(i-1)/2] < arr[i]) { swap(arr[i], arr[(i-1)/2]); i=(i-1)/2; }**
**Â    }**
**Â    int extractMax() {**
**Â        if(size==0) return -1;**
**Â        int root = arr[0]; arr[0]=arr[--size];**
**Â        int i=0;**
**Â        while(true) {**
**Â            int l=2*i+1, r=2*i+2, largest=i;**
**Â            if(l<size && arr[l]>arr[largest]) largest=l;**
**Â            if(r<size && arr[r]>arr[largest]) largest=r;**
**Â            if(largest==i) break;**
**Â            swap(arr[i], arr[largest]); i=largest;**
**Â        }**
**Â        return root;**
**Â    }**
**Â    bool empty() { return size==0; }**
};

struct MinHeap {
**Â    int arr[100]; int size;**
**Â    MinHeap(): size(0) {}**
**Â    void insert(int val) {**
**Â        arr[size++]=val; int i=size-1;**
**Â        while(i && arr[(i-1)/2] > arr[i]) { swap(arr[i], arr[(i-1)/2]); i=(i-1)/2; }**
**Â    }**
**Â    int extractMin() {**
**Â        if(size==0) return -1;**
**Â        int root=arr[0]; arr[0]=arr[--size];**
**Â        int i=0;**
**Â        while(true) {**
**Â            int l=2*i+1, r=2*i+2, smallest=i;**
**Â            if(l<size && arr[l]<arr[smallest]) smallest=l;**
**Â            if(r<size && arr[r]<arr[smallest]) smallest=r;**
**Â            if(smallest==i) break;**
**Â            swap(arr[i], arr[smallest]); i=smallest;**
**Â        }**
**Â        return root;**
**Â    }**
**Â    bool empty() { return size==0; }**
};

// ---------------------- Graph: adjacency matrix + edge list ----------------------
int nodesCount = 0;
int adjMat[MAX_NODES][MAX_NODES]; // INF for no edge, weight = cost/loss
struct Edge { int u,v,w; };
Edge edges[MAX_EDGES];
int edgesCount = 0;

void initGraph(int n) {
**Â    nodesCount = n;**
**Â    for(int i=0;i<n;i++) for(int j=0;j<n;j++) adjMat[i][j] = (i==j?0:INF);**
**Â    edgesCount = 0;**
}
void addEdge(int u,int v,int w) {
**Â    if(u<0||u>=nodesCount||v<0||v>=nodesCount) return;**
**Â    adjMat[u][v] = w; adjMat[v][u] = w; // undirected pipe**
**Â    if(edgesCount < MAX_EDGES) edges[edgesCount++] = {u,v,w};**
}

// ---------------------- Dijkstra (array-based) ----------------------
void dijkstraArray(int src, int dist[], int parent[]) {
**Â    bool used[MAX_NODES]; for(int i=0;i<nodesCount;i++){ dist[i]=INF; parent[i]=-1; used[i]=false; }**
**Â    dist[src]=0;**
**Â    for(int it=0; it<nodesCount; ++it) {**
**Â        int u=-1, best=INF;**
**Â        for(int i=0;i<nodesCount;i++) if(!used[i] && dist[i]<best){ best=dist[i]; u=i; }**
**Â        if(u==-1) break;**
**Â        used[u]=true;**
**Â        for(int v=0; v<nodesCount; ++v) {**
**Â            if(adjMat[u][v]<INF && dist[u]+adjMat[u][v] < dist[v]) {**
**Â                dist[v] = dist[u] + adjMat[u][v];**
**Â                parent[v] = u;**
**Â            }**
**Â        }**
**Â    }**
}

// ---------------------- Bellman-Ford (edge list) ----------------------
bool bellmanFord(int src, int dist[]) {
**Â    for(int i=0;i<nodesCount;i++) dist[i]=INF;**
**Â    dist[src]=0;**
**Â    for(int k=0;k<nodesCount-1;k++){**
**Â        bool changed=false;**
**Â        for(int e=0;e<edgesCount;e++){**
**Â            int u=edges[e].u, v=edges[e].v, w=edges[e].w;**
**Â            if(dist[u]<INF && dist[u]+w < dist[v]) { dist[v]=dist[u]+w; changed=true; }**
**Â            if(dist[v]<INF && dist[v]+w < dist[u]) { dist[u]=dist[v]+w; changed=true; } // undirected edges handled**
**Â        }**
**Â        if(!changed) break;**
**Â    }**
**Â    // no negative edges expected; skip negative cycle check**
**Â    return true;**
}

// ---------------------- Union-Find for Kruskal ----------------------
int parentUF[MAX_NODES];
int rankUF[MAX_NODES];
void ufInit(int n){ for(int i=0;i<n;i++){ parentUF[i]=i; rankUF[i]=0; } }
int ufFind(int x){ return parentUF[x]==x?x:parentUF[x]=ufFind(parentUF[x]); }
void ufUnion(int x,int y){ x=ufFind(x); y=ufFind(y); if(x==y) return; if(rankUF[x]<rankUF[y]) parentUF[x]=y; else if(rankUF[y]<rankUF[x]) parentUF[y]=x; else { parentUF[y]=x; rankUF[x]++; } }

// ---------------------- Merge Sort for edges (used in Kruskal) ----------------------
void mergeEdges(Edge a[], int l, int m, int r) {
**Â    int n1=m-l+1, n2=r-m;**
**Â    Edge L[100], R[100]; // adjust sizes if large**
**Â    for(int i=0;i<n1;i++) L[i]=a[l+i];**
**Â    for(int j=0;j<n2;j++) R[j]=a[m+1+j];**
**Â    int i=0,j=0,k=l;**
**Â    while(i<n1 && j<n2) {**
**Â        if(L[i].w <= R[j].w) a[k++]=L[i++]; else a[k++]=R[j++];**
**Â    }**
**Â    while(i<n1) a[k++]=L[i++];**
**Â    while(j<n2) a[k++]=R[j++];**
}
void mergeSortEdges(Edge a[], int l, int r) {
**Â    if(l<r) { int m=(l+r)/2; mergeSortEdges(a,l,m); mergeSortEdges(a,m+1,r); mergeEdges(a,l,m,r); }**
}

// ---------------------- Kruskal MST ----------------------
Edge mstEdges[MAX_NODES]; int mstCount=0;
int kruskalMST() {
**Â    if(edgesCount==0) return 0;**
**Â    // copy edges to temp array**
**Â    Edge tmp[MAX_EDGES];**
**Â    for(int i=0;i<edgesCount;i++) tmp[i]=edges[i];**
**Â    mergeSortEdges(tmp, 0, edgesCount-1);**
**Â    ufInit(nodesCount); mstCount=0;**
**Â    int cost=0;**
**Â    for(int i=0;i<edgesCount && mstCount < nodesCount-1;i++){**
**Â        int u = tmp[i].u, v = tmp[i].v;**
**Â        if(ufFind(u) != ufFind(v)) {**
**Â            ufUnion(u,v);**
**Â            mstEdges[mstCount++] = tmp[i];**
**Â            cost += tmp[i].w;**
**Â        }**
**Â    }**
**Â    return cost;**
}

// ---------------------- Prim MST (array-based) ----------------------
int primMST(int outParent[]) {
**Â    bool inMST[MAX_NODES]; int key[MAX_NODES];**
**Â    for(int i=0;i<nodesCount;i++){ inMST[i]=false; key[i]=INF; outParent[i]=-1; }**
**Â    key[0]=0;**
**Â    for(int cnt=0; cnt<nodesCount; ++cnt) {**
**Â        int u=-1, best=INF;**
**Â        for(int v=0; v<nodesCount; ++v) if(!inMST[v] && key[v]<best){ best=key[v]; u=v; }**
**Â        if(u==-1) break;**
**Â        inMST[u]=true;**
**Â        for(int v=0; v<nodesCount; ++v) {**
**Â            if(adjMat[u][v]<INF && !inMST[v] && adjMat[u][v] < key[v]) {**
**Â                key[v] = adjMat[u][v];**
**Â                outParent[v] = u;**
**Â            }**
**Â        }**
**Â    }**
**Â    int totalCost=0;**
**Â    for(int i=1;i<nodesCount;i++) if(outParent[i]!=-1) totalCost += adjMat[i][outParent[i]];**
**Â    return totalCost;**
}

// ---------------------- Merge Sort for Logs ----------------------
struct Log { int node; double delivered; int time; };
Log logs[500]; int logsSize=0;
void mergeLogs(Log a[], int l, int m, int r) {
**Â    int n1=m-l+1, n2=r-m;**
**Â    Log L[250], R[250];**
**Â    for(int i=0;i<n1;i++) L[i]=a[l+i];**
**Â    for(int j=0;j<n2;j++) R[j]=a[m+1+j];**
**Â    int i=0,j=0,k=l;**
**Â    while(i<n1 && j<n2) {**
**Â        if(L[i].delivered >= R[j].delivered) a[k++]=L[i++]; else a[k++]=R[j++];**
**Â    }**
**Â    while(i<n1) a[k++]=L[i++];**
**Â    while(j<n2) a[k++]=R[j++];**
}
void mergeSortLogs(Log a[], int l, int r) { if(l<r){ int m=(l+r)/2; mergeSortLogs(a,l,m); mergeSortLogs(a,m+1,r); mergeLogs(a,l,m,r); } }

// ---------------------- KMP (for meter ID/name search) ----------------------
void computeLPS(const char* pat, int M, int lps[]) {
**Â    int len=0; lps[0]=0; int i=1;**
**Â    while(i<M) {**
**Â        if(pat[i]==pat[len]) { len++; lps[i]=len; i++; }**
**Â        else { if(len!=0) len=lps[len-1]; else { lps[i]=0; i++; } }**
**Â    }**
}
bool KMPsearch(const char* txt, const char* pat) {
**Â    int N = strlen(txt), M = strlen(pat);**
**Â    if(M==0) return true;**
**Â    int lps[128]; computeLPS(pat,M,lps);**
**Â    int i=0,j=0;**
**Â    while(i<N) {**
**Â        if(txt[i]==pat[j]) { i++; j++; if(j==M) return true; }**
**Â        else { if(j) j=lps[j-1]; else i++; }**
**Â    }**
**Â    return false;**
}

// ---------------------- Demo & Simulation Utilities ----------------------
void addLogEntry(int node, double delivered, int time) { if(logsSize<500) logs[logsSize++] = {node, delivered, time}; }

void demoSetup() {
**Â    // simple graph example**
**Â    initGraph(7);**
**Â    addEdge(0,1,4); addEdge(0,2,3); addEdge(1,2,1);**
**Â    addEdge(1,3,2); addEdge(2,4,5); addEdge(3,4,3);**
**Â    addEdge(3,5,7); addEdge(4,6,4);**
**Â    // customers demo**
}

void printMSTKruskal() {
**Â    cout << "Kruskal MST edges (u-v : w):\n";**
**Â    for(int i=0;i<mstCount;i++) cout<< mstEdges[i].u << "-" << mstEdges[i].v << " : " << mstEdges[i].w << "\n";**
}
void printPrimParent(int parent[]) {
**Â    cout << "Prim MST parent list (v <- parent):\n";**
**Â    for(int i=1;i<nodesCount;i++) cout << i << " <- " << parent[i] << " (w="<<adjMat[i][parent[i]]<<")\n";**
}

// ---------------------- Main demo ----------------------
int main(){
**Â    cout << "=== Bellapuram Water Distribution System (No vectors) ===\n\n";**

**Â    // 1) Setup graph**
**Â    demoSetup();**

**Â    // 2) Register some customers (AVL)**
**Â    AVLNode* custRoot=nullptr;**
**Â    Customer c1; c1.meterId=1001; strcpy(c1.name,"Rahul"); c1.node=3; c1.avgDaily=250.5;**
**Â    Customer c2; c2.meterId=1002; strcpy(c2.name,"Meena"); c2.node=4; c2.avgDaily=180.0;**
**Â    Customer c3; c3.meterId=1003; strcpy(c3.name,"ShopA"); c3.node=5; c3.avgDaily=500.0;**
**Â    custRoot = insertAVL(custRoot, c1);**
**Â    custRoot = insertAVL(custRoot, c2);**
**Â    custRoot = insertAVL(custRoot, c3);**
**Â    cout<<"Registered customers (inorder by meterId):\n";**
**Â    // inorder print simple:**
**Â    function<void(AVLNode*)> inorderPrint = [&](AVLNode* r){**
**Â        if(!r) return; inorderPrint(r->left); cout<< r->cust.meterId << " " << r->cust.name << " node="<<r->cust.node<<"\n"; inorderPrint(r->right);**
**Â    };**
**Â    inorderPrint(custRoot);**
**Â    cout<<"\n";**

**Â    // 3) Pump priority using MaxHeap (choose largest capacity pump)**
**Â    MaxHeap pumpHeap;**
**Â    pumpHeap.insert(500); pumpHeap.insert(300); pumpHeap.insert(700);**
**Â    cout << "Top pump capacity selected (kL): " << pumpHeap.extractMax() << "\n\n";**

**Â    // 4) Route for critical node (use Dijkstra)**
**Â    int dist[ MAX_NODES ], parent[MAX_NODES ];**
**Â    dijkstraArray(0, dist, parent);**
**Â    cout << "Dijkstra dist from reservoir(0):\n";**
**Â    for(int i=0;i<nodesCount;i++) cout << "node " << i << " dist=" << (dist[i]>=INF? -1: dist[i]) << "\n";**
**Â    cout<<"\n";**

**Â    // 5) Bellman-Ford as alternative**
**Â    int distBF[MAX_NODES];**
**Â    bellmanFord(0, distBF);**
**Â    cout << "Bellman-Ford dist from 0:\n";**
**Â    for(int i=0;i<nodesCount;i++) cout << i << " -> " << distBF[i] << "\n";**
**Â    cout<<"\n";**

**Â    // 6) Build MST using Kruskal**
**Â    int costK = kruskalMST();**
**Â    cout << "Kruskal MST total cost: " << costK << "\n";**
**Â    printMSTKruskal();**
**Â    cout<<"\n";**

**Â    // 7) Prim MST**
**Â    int primParent[MAX_NODES];**
**Â    int costP = primMST(primParent);**
**Â    cout << "Prim MST total cost: " << costP << "\n";**
**Â    printPrimParent(primParent);**
**Â    cout<<"\n";**

**Â    // 8) Detect low-performing nodes via MinHeap (e.g., delivered volume below threshold)**
**Â    // simulate delivered volumes**
**Â    int volumes[7] = {1200, 800, 950, 400, 700, 350, 600}; // example liters/hour**
**Â    MinHeap low;**
**Â    for(int i=0;i<nodesCount;i++) low.insert(volumes[i]);**
**Â    cout << "Lowest performed node volume (L/h): " << low.extractMin() << "\n\n";**

**Â    // 9) Logs and sorting**
**Â    addLogEntry(3, 240.0, 9); addLogEntry(4, 180.0, 9); addLogEntry(5, 500.0, 9);**
**Â    addLogEntry(3, 260.0, 10); addLogEntry(5, 480.0, 10);**
**Â    cout << "Logs before sort (node : delivered):\n"; for(int i=0;i<logsSize;i++) cout<<logs[i].node<<" : "<<logs[i].delivered<<"\n";**
**Â    mergeSortLogs(logs, 0, logsSize-1);**
**Â    cout << "Logs after sort (delivered desc):\n"; for(int i=0;i<logsSize;i++) cout<<logs[i].node<<" : "<<logs[i].delivered<<"\n\n";**

**Â    // 10) KMP search demo (meter name)**
**Â    const char* txt = "Meter-1003-ShopA";**
**Â    const char* pat = "ShopA";**
**Â    cout << "KMP search for 'ShopA' in '"<<txt<<"' -> " << (KMPsearch(txt,pat)? "FOUND":"NOT FOUND") << "\n\n";**

**Â    cout << "Demo complete.\n";**
**Â    return 0;**
}

`
  },
  emergency: {
  title: 'Emergency Response Dispatch System (Hydrology)',
  desc: `
    <h3>Problem Statement</h3>
    <p>Delayed response during floods increases damage and loss of life.</p>

    <h3>System Approach</h3>
    <p>The system predicts flood advance, proactively closes roads, prepositions vehicles, and activates drainage pumps.</p>

    <h3>Algorithms Used</h3>
    <p>BFS / DFS (graph traversal), Dijkstra (rerouting), Time-series forecasting, Rule-based scheduling</p>

    <h3>ğŸš¨ Emergency Response Dispatch System (Hydrology)</h3>
    <ul>
      <li><b>Flood Prediction:</b> Forecasting models â€“ predict short-term flood rise using rainfall & river sensor data</li>
      <li><b>Proactive Road Closures:</b> Graph traversal (BFS/DFS) â€“ block routes before they become impassable</li>
      <li><b>Vehicle & Pump Pre-positioning:</b> Scheduling + shortest path â€“ stage ambulances & pumps near safe nodes</li>
      <li><b>Pump Activation:</b> Rule-based triggers â€“ increase drainage capacity to reduce flood risk</li>
    </ul>

    <p><b>SDGs:</b> SDGâ€‘3, SDGâ€‘11, SDGâ€‘9</p>
  `,

    code:`#include <bits/stdc++.h>
using namespace std;
const int MAX_NODES = 60;
const int MAX_EDGES = 300;
const int MAX_SENSORS = 60;
const int MAX_ALERTS = 400;
const int MAX_INCIDENTS = 500;
const int MAX_VEHICLES = 80;
const int INF = 1000000000;

/* ---------------- Graph and edges ---------------- */
struct Edge { int u,v,w; bool blocked; bool proactivelyClosed; };
int nodesCount = 0;
int adjMat[MAX_NODES][MAX_NODES];
Edge edges[MAX_EDGES]; int edgesCount = 0;

void initGraph(int n) {
    **\*\*nodesCount = n;\*\*

    \*\*edgesCount = 0;\*\*

    \*\*for(int i=0;i<n;i++) for(int j=0;j<n;j++) adjMat\\\[i]\\\[j] = (i==j?0:INF);\*\***



}
void addEdge(int u,int v,int w) {
    **\*\*if(u<0||v<0||u>=nodesCount||v>=nodesCount) return;\*\*

    \*\*adjMat\\\[u]\\\[v] = w; adjMat\\\[v]\\\[u] = w;\*\*

    \*\*if(edgesCount < MAX\\\_EDGES) { edges\\\[edgesCount++] = {u,v,w,false,false}; }\*\***



}

/* ------------- Dijkstra (respects blocked and proactivelyClosed edges) ------------- */
struct DRes { int dist[MAX_NODES]; int parent[MAX_NODES]; };
DRes dijkstraAvoidBlocked(int src) {
    **\*\*DRes R; bool used\\\[MAX\\\_NODES];\*\*

    \*\*for(int i=0;i<nodesCount;i++){ R.dist\\\[i]=INF; R.parent\\\[i]=-1; used\\\[i]=false; }\*\*

    \*\*R.dist\\\[src] = 0;\*\*

    \*\*for(int iter=0; iter<nodesCount; ++iter) {\*\*

        \*\*int u=-1, best=INF;\*\*

        \*\*for(int i=0;i<nodesCount;i++) if(!used\\\[i] \\\&\\\& R.dist\\\[i] < best) { best = R.dist\\\[i]; u = i; }\*\*

        \*\*if(u==-1) break;\*\*

        \*\*used\\\[u] = true;\*\*

        \*\*for(int v=0; v<nodesCount; ++v) {\*\*

            \*\*// skip blocked or proactively closed edges\*\*

            \*\*bool blocked = false;\*\*

            \*\*for(int e=0;e<edgesCount;e++) {\*\*

                \*\*if( (edges\\\[e].u==u \\\&\\\& edges\\\[e].v==v) || (edges\\\[e].u==v \\\&\\\& edges\\\[e].v==u) ) {\*\*

                    \*\*if(edges\\\[e].blocked || edges\\\[e].proactivelyClosed) blocked = true;\*\*

                \*\*}\*\*

            \*\*}\*\*

            \*\*if(blocked) continue;\*\*

            \*\*if(adjMat\\\[u]\\\[v] < INF \\\&\\\& R.dist\\\[u] + adjMat\\\[u]\\\[v] < R.dist\\\[v]) {\*\*

                \*\*R.dist\\\[v] = R.dist\\\[u] + adjMat\\\[u]\\\[v];\*\*

                \*\*R.parent\\\[v] = u;\*\*

            \*\*}\*\*

        \*\*}\*\*

    \*\*}\*\*

    \*\*return R;\*\***



}

/* ---------------- Kruskal & Prim for evacuation backbone ---------------- */
int parentUF[MAX_NODES], rankUF[MAX_NODES];
void ufInit(int n){ for(int i=0;i<n;i++){ parentUF[i]=i; rankUF[i]=0; } }
int ufFind(int x){ return parentUF[x]==x?x:parentUF[x]=ufFind(parentUF[x]); }
void ufUnion(int a,int b){ a=ufFind(a); b=ufFind(b); if(a==b) return; if(rankUF[a]<rankUF[b]) parentUF[a]=b; else if(rankUF[b]<rankUF[a]) parentUF[b]=a; else { parentUF[b]=a; rankUF[a]++; } }

void sortEdgesByWeight(Edge arr[], int n) {
    **\*\*if(n<=1) return;\*\*

    \*\*int m = n/2;\*\*

    \*\*Edge \\\*L = new Edge\\\[m], \\\*R = new Edge\\\[n-m];\*\*

    \*\*for(int i=0;i<m;i++) L\\\[i]=arr\\\[i];\*\*

    \*\*for(int i=0;i<n-m;i++) R\\\[i]=arr\\\[m+i];\*\*

    \*\*sortEdgesByWeight(L,m); sortEdgesByWeight(R,n-m);\*\*

    \*\*int i=0,j=0,k=0;\*\*

    \*\*while(i<m \\\&\\\& j<n-m) arr\\\[k++] = (L\\\[i].w <= R\\\[j].w ? L\\\[i++] : R\\\[j++]);\*\*

    \*\*while(i<m) arr\\\[k++] = L\\\[i++]; while(j<n-m) arr\\\[k++] = R\\\[j++]; delete\\\[] L; delete\\\[] R;\*\***



}
int kruskalMSTOnSubgraph(int nodeMask[], int maskSize, Edge out[], int &outCount) {
    **\*\*Edge temp\\\[ MAX\\\_EDGES ]; int tc=0;\*\*

    \*\*for(int e=0;e<edgesCount;e++) {\*\*

        \*\*int u = edges\\\[e].u, v = edges\\\[e].v;\*\*

        \*\*bool uok=false, vok=false;\*\*

        \*\*for(int i=0;i<maskSize;i++){ if(nodeMask\\\[i]==u) uok=true; if(nodeMask\\\[i]==v) vok=true; }\*\*

        \*\*if(uok \\\&\\\& vok \\\&\\\& !edges\\\[e].blocked \\\&\\\& !edges\\\[e].proactivelyClosed) temp\\\[tc++] = edges\\\[e];\*\*

    \*\*}\*\*

    \*\*sortEdgesByWeight(temp, tc);\*\*

    \*\*ufInit(nodesCount); outCount=0; int cost=0;\*\*

    \*\*for(int i=0;i<tc \\\&\\\& outCount < maskSize-1;i++){\*\*

        \*\*int u=temp\\\[i].u, v=temp\\\[i].v;\*\*

        \*\*if(ufFind(u) != ufFind(v)) { ufUnion(u,v); out\\\[outCount++]=temp\\\[i]; cost += temp\\\[i].w; }\*\*

    \*\*}\*\*

    \*\*return cost;\*\***



}
int primMSTCostOnSubgraph(int nodeMask[], int maskSize, int parentOut[]) {
    **\*\*bool inMST\\\[MAX\\\_NODES]; int key\\\[MAX\\\_NODES]; for(int i=0;i<nodesCount;i++){ inMST\\\[i]=false; key\\\[i]=INF; parentOut\\\[i]=-1; }\*\*

    \*\*int root = nodeMask\\\[0]; key\\\[root]=0;\*\*

    \*\*for(int iter=0; iter<maskSize; ++iter) {\*\*

        \*\*int u=-1, best=INF;\*\*

        \*\*for(int i=0;i<maskSize;i++){ int v=nodeMask\\\[i]; if(!inMST\\\[v] \\\&\\\& key\\\[v] < best){ best=key\\\[v]; u=v; } }\*\*

        \*\*if(u==-1) break;\*\*

        \*\*inMST\\\[u]=true;\*\*

        \*\*for(int i=0;i<maskSize;i++){\*\*

            \*\*int v = nodeMask\\\[i];\*\*

            \*\*// skip blocked edges\*\*

            \*\*if(adjMat\\\[u]\\\[v] < INF) {\*\*

                \*\*bool blocked=false;\*\*

                \*\*for(int e=0;e<edgesCount;e++) if((edges\\\[e].u==u \\\&\\\& edges\\\[e].v==v) || (edges\\\[e].u==v \\\&\\\& edges\\\[e].v==u)) if(edges\\\[e].blocked || edges\\\[e].proactivelyClosed) blocked=true;\*\*

                \*\*if(blocked) continue;\*\*

                \*\*if(!inMST\\\[v] \\\&\\\& adjMat\\\[u]\\\[v] < key\\\[v]) { key\\\[v] = adjMat\\\[u]\\\[v]; parentOut\\\[v] = u; }\*\*

            \*\*}\*\*

        \*\*}\*\*

    \*\*}\*\*

    \*\*int total=0; for(int i=0;i<maskSize;i++){ int v = nodeMask\\\[i]; if(parentOut\\\[v] != -1) total += adjMat\\\[v]\\\[ parentOut\\\[v] ]; }\*\*

    \*\*return total;\*\***



}

/* ---------------- Flood model: hydrology sensors per node ---------------- */
struct FloodSensor {
    **\*\*int node;\*\*

    \*\*double riverLevel;      // cm\*\*

    \*\*double rainfall;        // mm in window\*\*

    \*\*double runoffCoeff;     // 0..1\*\*

    \*\*double soilAbsorption;  // mm/hr\*\*

    \*\*double elevation;       // m\*\*

    \*\*double drainageCapacity; // L/hr\*\*

    \*\*double floodRiskScore;\*\*

    \*\*bool flooded;\*\***



} sensors[MAX_SENSORS];
int sensorsCount = 0;

int findSensorIdx(int node) {
    **\*\*for(int i=0;i<sensorsCount;i++) if(sensors\\\[i].node == node) return i;\*\*

    \*\*return -1;\*\***



}
void addSensor(int node,double river,double rain,double runoff,double soilAbs,double elev,double drainage) {
    **\*\*if(sensorsCount >= MAX\\\_SENSORS) return;\*\*

    \*\*sensors\\\[sensorsCount].node=node; sensors\\\[sensorsCount].riverLevel=river; sensors\\\[sensorsCount].rainfall=rain;\*\*

    \*\*sensors\\\[sensorsCount].runoffCoeff=runoff; sensors\\\[sensorsCount].soilAbsorption=soilAbs; sensors\\\[sensorsCount].elevation=elev;\*\*

    \*\*sensors\\\[sensorsCount].drainageCapacity=drainage; sensors\\\[sensorsCount].floodRiskScore=0; sensors\\\[sensorsCount].flooded=false;\*\*

    \*\*sensorsCount++;\*\***



}

/* Risk computation (hydrology-based) */
void computeFloodRiskAll() {
    **\*\*const double maxRiver = 500.0, maxRain=500.0;\*\*

    \*\*for(int i=0;i<sensorsCount;i++) {\*\*

        \*\*FloodSensor \\\&s = sensors\\\[i];\*\*

        \*\*double normRiver = min(1.0, s.riverLevel / maxRiver);\*\*

        \*\*double normRain = min(1.0, s.rainfall / maxRain);\*\*

        \*\*double runoff = s.runoffCoeff;\*\*

        \*\*double drainage = s.drainageCapacity / 10000.0;\*\*

        \*\*double elevFactor = 1.0 / (1.0 + max(0.01, s.elevation));\*\*

        \*\*double score = 2.5\\\*normRiver + 2.0\\\*normRain + 2.0\\\*runoff - 1.8\\\*drainage + 3.0\\\*elevFactor - 1.0\\\*(s.soilAbsorption/100.0);\*\*

        \*\*if(score < 0) score = 0;\*\*

        \*\*bool wasFlooded = s.flooded;\*\*

        \*\*s.floodRiskScore = score;\*\*

        \*\*s.flooded = (s.floodRiskScore > 3.2 || s.riverLevel > 300.0 || (s.rainfall > 220.0 \\\&\\\& s.elevation < 2.0));\*\*

        \*\*if(s.flooded \\\&\\\& !wasFlooded) {\*\*

            \*\*for(int e=0;e<edgesCount;e++) if(edges\\\[e].u==s.node || edges\\\[e].v==s.node) edges\\\[e].blocked = true;\*\*

        \*\*}\*\*

        \*\*if(!s.flooded \\\&\\\& wasFlooded) {\*\*

            \*\*for(int e=0;e<edgesCount;e++) if(edges\\\[e].u==s.node || edges\\\[e].v==s.node) edges\\\[e].blocked = false;\*\*

        \*\*}\*\*

    \*\*}\*\***



}

/* -------------- Min-Heap for high-risk sensors -------------- */
int floodHeapArr[MAX_SENSORS]; int floodHeapSize = 0;
void floodHeapPush(int sensorIdx) {
    **\*\*floodHeapArr\\\[floodHeapSize] = sensorIdx; int i=floodHeapSize++;\*\*

    \*\*while(i!=0){ int p=(i-1)/2; if(sensors\\\[floodHeapArr\\\[i]].floodRiskScore > sensors\\\[floodHeapArr\\\[p]].floodRiskScore){ int t=floodHeapArr\\\[i]; floodHeapArr\\\[i]=floodHeapArr\\\[p]; floodHeapArr\\\[p]=t; i=p; } else break; }\*\***



}
int floodHeapPop() {
    **\*\*if(floodHeapSize==0) return -1;\*\*

    \*\*int root = floodHeapArr\\\[0]; floodHeapArr\\\[0] = floodHeapArr\\\[--floodHeapSize];\*\*

    \*\*int i=0;\*\*

    \*\*while(true) {\*\*

        \*\*int l=2\\\*i+1, r=2\\\*i+2, largest=i;\*\*

        \*\*if(l<floodHeapSize \\\&\\\& sensors\\\[floodHeapArr\\\[l]].floodRiskScore > sensors\\\[floodHeapArr\\\[largest]].floodRiskScore) largest=l;\*\*

        \*\*if(r<floodHeapSize \\\&\\\& sensors\\\[floodHeapArr\\\[r]].floodRiskScore > sensors\\\[floodHeapArr\\\[largest]].floodRiskScore) largest=r;\*\*

        \*\*if(largest!=i){ int t=floodHeapArr\\\[i]; floodHeapArr\\\[i]=floodHeapArr\\\[largest]; floodHeapArr\\\[largest]=t; i=largest; } else break;\*\*

    \*\*}\*\*

    \*\*return root;\*\***



}

/* --------------- Alert system (SMS / siren) --------------- */
struct Alert { char text[200]; int node; int severity; int timestamp; };
Alert alertQueue[MAX_ALERTS]; int alertHead=0, alertTail=0, alertCount=0;
void enqueueAlert(const char* txt, int node, int severity, int timestamp) {
    **\*\*if(alertCount==MAX\\\_ALERTS) { alertHead=(alertHead+1)%MAX\\\_ALERTS; alertCount--; }\*\*

    \*\*strncpy(alertQueue\\\[alertTail].text, txt, 199); alertQueue\\\[alertTail].text\\\[199]=0;\*\*

    \*\*alertQueue\\\[alertTail].node = node; alertQueue\\\[alertTail].severity = severity; alertQueue\\\[alertTail].timestamp = timestamp;\*\*

    \*\*alertTail = (alertTail+1)%MAX\\\_ALERTS; alertCount++;\*\***



}
void processAlerts() {
    **\*\*while(alertCount>0) {\*\*

        \*\*Alert \\\&a = alertQueue\\\[alertHead];\*\*

        \*\*cout<<"\\\[ALERT ts="<<a.timestamp<<"] Node "<<a.node<<" severity="<<a.severity<<" : "<<a.text<<"\\\\n";\*\*

        \*\*alertHead = (alertHead+1)%MAX\\\_ALERTS; alertCount--;\*\*

    \*\*}\*\***



}

/* --------------- Vehicles (ambulances, trucks, boats) --------------- */
struct Vehicle { int id; int type; int currentNode; int capacity; int load; bool available; int speed; int destNode; int remainingDist; int assignedIncidentIdx; };
Vehicle vehicles[MAX_VEHICLES]; int vehiclesCount=0;
enum VehicleType { VT_AMBULANCE=0, VT_TRUCK=1, VT_BOAT=2, VT_PUMP=3 };
void addVehicle(int id,int type,int startNode,int cap,int speed) {
    **\*\*if(vehiclesCount >= MAX\\\_VEHICLES) return;\*\*

    \*\*vehicles\\\[vehiclesCount].id=id; vehicles\\\[vehiclesCount].type=type; vehicles\\\[vehiclesCount].currentNode=startNode; vehicles\\\[vehiclesCount].capacity=cap; vehicles\\\[vehiclesCount].load=0; vehicles\\\[vehiclesCount].available=true; vehicles\\\[vehiclesCount].speed=speed; vehicles\\\[vehiclesCount].destNode=-1; vehicles\\\[vehiclesCount].remainingDist=0; vehicles\\\[vehiclesCount].assignedIncidentIdx=-1; vehiclesCount++;\*\***



}

/* --------------- Incidents (evacuations) --------------- */
struct Incident { int id; int node; int severity; bool handled; };
Incident incidents[MAX_INCIDENTS]; int incidentsCount=0; int nextIncidentId=1;
void createEvacuationIncident(int node,int severity) {
    **\*\*if(incidentsCount >= MAX\\\_INCIDENTS) return;\*\*

    \*\*incidents\\\[incidentsCount].id = nextIncidentId++; incidents\\\[incidentsCount].node = node; incidents\\\[incidentsCount].severity = severity; incidents\\\[incidentsCount].handled=false;\*\*

    \*\*incidentsCount++;\*\***



}

/* --------------- Preventative Measures --------------- */

/* Predict near-future flood (simple linear forecast) -> returns predicted risk increment per sensor */
void predictFloodAdvance(int minsAhead, double predictedIncrease[]) {
    **\*\*// simplistic model: predictedIncrease = rainfallFactor\\\*minsAhead + riverRise\\\*0.1\\\*minsAhead\*\*

    \*\*for(int i=0;i<sensorsCount;i++) {\*\*

        \*\*double rainRate = sensors\\\[i].rainfall / 60.0; // mm per hour -> mm per minute approx\*\*

        \*\*double riverRate = sensors\\\[i].riverLevel / 720.0; // cm per 12 hours -> cm per minute approx\*\*

        \*\*double inc = (rainRate \\\* minsAhead)/50.0 + (riverRate \\\* minsAhead)/200.0; // normalize\*\*

        \*\*predictedIncrease\\\[i] = inc; // additive to floodRiskScore scale\*\*

    \*\*}\*\***



}

/* Proactive road closure: close edges near nodes that are predicted to flood */
void proactiveRoadClosures(double predictedIncrease[], double threshold) {
    **\*\*for(int i=0;i<sensorsCount;i++) {\*\*

        \*\*if(predictedIncrease\\\[i] > threshold) {\*\*

            \*\*int node = sensors\\\[i].node;\*\*

            \*\*for(int e=0;e<edgesCount;e++) if(edges\\\[e].u==node || edges\\\[e].v==node) edges\\\[e].proactivelyClosed = true;\*\*

            \*\*char msg\\\[200]; snprintf(msg,200,"Proactive road closure around node %d due to forecasted flood risk.", node);\*\*

            \*\*enqueueAlert(msg, node, 5, 0);\*\*

        \*\*}\*\*

    \*\*}\*\***



}

/* Pre-position vehicles: stage ambulances/pumps at safe nearby nodes for high-risk sensors */
void prepositionVehicles(double predictedIncrease[], int currentTime) {
    **\*\*for(int i=0;i<sensorsCount;i++) {\*\*

        \*\*if(predictedIncrease\\\[i] > 0.6) { // threshold for staging\*\*

            \*\*int node = sensors\\\[i].node;\*\*

            \*\*// find a nearby safe node (lowest floodRiskScore) within nodesCount brute force\*\*

            \*\*int bestNode=-1; double bestScore=1e9;\*\*

            \*\*for(int n=0;n<nodesCount;n++) {\*\*

                \*\*int si = findSensorIdx(n);\*\*

                \*\*double score = (si==-1? 0.0 : sensors\\\[si].floodRiskScore);\*\*

                \*\*if(score < bestScore) { bestScore = score; bestNode = n; }\*\*

            \*\*}\*\*

            \*\*// reserve one ambulance and one pump vehicle and move them to bestNode if available\*\*

            \*\*for(int v=0; v<vehiclesCount; v++) {\*\*

                \*\*if(vehicles\\\[v].available \\\&\\\& vehicles\\\[v].type==VT\\\_AMBULANCE) {\*\*

                    \*\*vehicles\\\[v].available=false; vehicles\\\[v].destNode = bestNode;\*\*

                    \*\*vehicles\\\[v].remainingDist = 0; // teleport for preventative staging in this simple sim\*\*

                    \*\*char msg\\\[200]; snprintf(msg,200,"Pre-position Ambulance %d to staging node %d for potential flood at node %d", vehicles\\\[v].id, bestNode, node);\*\*

                    \*\*enqueueAlert(msg, bestNode, 3, currentTime);\*\*

                    \*\*break;\*\*

                \*\*}\*\*

            \*\*}\*\*

            \*\*for(int v=0; v<vehiclesCount; v++) {\*\*

                \*\*if(vehicles\\\[v].available \\\&\\\& vehicles\\\[v].type==VT\\\_PUMP) {\*\*

                    \*\*vehicles\\\[v].available=false; vehicles\\\[v].destNode = bestNode;\*\*

                    \*\*vehicles\\\[v].remainingDist = 0;\*\*

                    \*\*char msg\\\[200]; snprintf(msg,200,"Pre-position Pump Vehicle %d to node %d", vehicles\\\[v].id, bestNode);\*\*

                    \*\*enqueueAlert(msg, bestNode, 3, currentTime);\*\*

                    \*\*break;\*\*

                \*\*}\*\*

            \*\*}\*\*

        \*\*}\*\*

    \*\*}\*\***



}

/* Activate pumps at nodes (simulate drainage boosting) */
void activatePumpsAtNode(int node) {
    **\*\*int si = findSensorIdx(node);\*\*

    \*\*if(si==-1) return;\*\*

    \*\*// boosting drainage reduces flood risk by increasing drainageCapacity temporarily\*\*

    \*\*sensors\\\[si].drainageCapacity += 2000; // L/hr extra\*\*

    \*\*char msg\\\[200]; snprintf(msg,200,"Activated pumps at node %d to boost drainage.", node);\*\*

    \*\*enqueueAlert(msg, node, 4, 0);\*\***



}

/* Preventative alert dispatch: sends pre-evacuation notices to zones above threshold */
void sendPreventiveAlerts(double predictedIncrease[], int currentTime) {
    **\*\*for(int i=0;i<sensorsCount;i++) {\*\*

        \*\*if(predictedIncrease\\\[i] > 0.5 \\\&\\\& sensors\\\[i].floodRiskScore < 4.0) {\*\*

            \*\*char buf\\\[200]; snprintf(buf,200,"Preventive Warning: Please prepare to evacuate area %d; predicted risk rising.", sensors\\\[i].node);\*\*

            \*\*enqueueAlert(buf, sensors\\\[i].node, 2, currentTime);\*\*

        \*\*}\*\*

    \*\*}\*\***



}

/* Reserve resources (mark vehicle assigned/prevent redeployment) */
void reserveResourcesForNode(int node, int currentTime) {
    **\*\*// Reserve nearest ambulance/truck for node by marking available=false and assigning a placeholder task\*\*

    \*\*for(int v=0; v<vehiclesCount; v++) {\*\*

        \*\*if(vehicles\\\[v].available \\\&\\\& (vehicles\\\[v].type==VT\\\_AMBULANCE || vehicles\\\[v].type==VT\\\_TRUCK)) {\*\*

            \*\*vehicles\\\[v].available = false;\*\*

            \*\*vehicles\\\[v].destNode = node; vehicles\\\[v].remainingDist = 0;\*\*

            \*\*char msg\\\[200]; snprintf(msg,200,"Resource Reserve: Vehicle %d reserved for node %d", vehicles\\\[v].id, node);\*\*

            \*\*enqueueAlert(msg, node, 3, currentTime);\*\*

            \*\*break;\*\*

        \*\*}\*\*

    \*\*}\*\***



}

/* --------------- Simulation: integrated step --------------- */
void simulationStepWithPrevention(int currentTime) {
    **\*\*// 1) compute present flood risks\*\*

    \*\*computeFloodRiskAll();\*\*

    \*\*// 2) predict near future\*\*

    \*\*double predicted\\\[MAX\\\_SENSORS]; for(int i=0;i<sensorsCount;i++) predicted\\\[i]=0.0;\*\*

    \*\*predictFloodAdvance(60, predicted); // predict 60 minutes ahead\*\*

    \*\*// 3) proactive road closures\*\*

    \*\*proactiveRoadClosures(predicted, 0.7);\*\*

    \*\*// 4) send preventive alerts\*\*

    \*\*sendPreventiveAlerts(predicted, currentTime);\*\*

    \*\*// 5) pre-position vehicles/pumps\*\*

    \*\*prepositionVehicles(predicted, currentTime);\*\*

    \*\*// 6) reserve resources for highest predicted risk nodes\*\*

    \*\*// build heap and reserve for top 2 nodes\*\*

    \*\*floodHeapSize=0; for(int i=0;i<sensorsCount;i++) floodHeapPush(i);\*\*

    \*\*for(int k=0;k<2;k++){\*\*

        \*\*int idx = floodHeapPop(); if(idx==-1) break;\*\*

        \*\*if(predicted\\\[idx] > 0.6) { reserveResourcesForNode(sensors\\\[idx].node, currentTime); activatePumpsAtNode(sensors\\\[idx].node); }\*\*

    \*\*}\*\*

    \*\*// 7) re-evaluate flood risk and generate alerts/incidents (like before)\*\*

    \*\*floodHeapSize=0; for(int i=0;i<sensorsCount;i++) floodHeapPush(i);\*\*

    \*\*for(int k=0;k<3;k++){\*\*

        \*\*int idx = floodHeapPop(); if(idx==-1) break;\*\*

        \*\*FloodSensor \\\&s = sensors\\\[idx];\*\*

        \*\*if(s.floodRiskScore > 3.0) {\*\*

            \*\*char buf\\\[200]; snprintf(buf,200,"FLOOD ALERT: Node %d risk=%.2f (river=%.1f cm, rain=%.1f mm)", s.node, s.floodRiskScore, s.riverLevel, s.rainfall);\*\*

            \*\*enqueueAlert(buf, s.node, (int)ceil(s.floodRiskScore), currentTime);\*\*

            \*\*if(s.floodRiskScore > 4.0) createEvacuationIncident(s.node, (int)ceil(s.floodRiskScore));\*\*

        \*\*}\*\*

    \*\*}\*\*

    \*\*// 8) process alerts (print)\*\*

    \*\*processAlerts();\*\*

    \*\*// 9) evacuation planning on safe nodes\*\*

    \*\*int safeMask\\\[MAX\\\_NODES]; int safeCount=0;\*\*

    \*\*for(int n=0;n<nodesCount;n++) { int si=findSensorIdx(n); if(si==-1 || !sensors\\\[si].flooded) safeMask\\\[safeCount++]=n; }\*\*

    \*\*if(safeCount>1) {\*\*

        \*\*int primParentArr\\\[MAX\\\_NODES];\*\*

        \*\*int cost = primMSTCostOnSubgraph(safeMask, safeCount, primParentArr);\*\*

        \*\*cout<<"\\\[EvacPlan] Evacuation MST cost="<<cost<<" over "<<safeCount<<" safe nodes.\\\\n";\*\*

    \*\*} else cout<<"\\\[EvacPlan] Not enough safe nodes.\\\\n";\*\*

    \*\*// 10) handle incidents by computing safe shelter and generating targeted evacuation route\*\*

    \*\*for(int i=0;i<incidentsCount;i++){\*\*

        \*\*Incident \\\&inc = incidents\\\[i];\*\*

        \*\*if(inc.handled) continue;\*\*

        \*\*DRes dr = dijkstraAvoidBlocked(inc.node);\*\*

        \*\*int shelter=-1; int bestd=INF;\*\*

        \*\*for(int s=0;s<nodesCount;s++){ int si=findSensorIdx(s); if(si==-1 || !sensors\\\[si].flooded) { if(dr.dist\\\[s] < bestd){ bestd = dr.dist\\\[s]; shelter = s; }}}\*\*

        \*\*if(shelter==-1) {\*\*

            \*\*cout<<"\\\[Evac] No shelter reachable for incident "<<inc.id<<" node "<<inc.node<<"\\\\n";\*\*

            \*\*continue;\*\*

        \*\*}\*\*

        \*\*// print route\*\*

        \*\*int path\\\[MAX\\\_NODES]; int plen=0; int cur=shelter;\*\*

        \*\*while(cur!=-1){ path\\\[plen++]=cur; cur=dr.parent\\\[cur]; if(plen>nodesCount) break; }\*\*

        \*\*cout<<"\\\[Evac] Incident "<<inc.id<<" node "<<inc.node<<" -> shelter "<<shelter<<" dist="<<bestd<<" path: ";\*\*

        \*\*for(int p=plen-1;p>=0;p--){ cout<<path\\\[p]; if(p) cout<<"->"; } cout<<"\\\\n";\*\*

        \*\*// auto-dispatch nearest ambulance if available\*\*

        \*\*int bestVeh=-1, bestDist=INF;\*\*

        \*\*for(int v=0; v<vehiclesCount; v++) if(vehicles\\\[v].available \\\&\\\& vehicles\\\[v].type==VT\\\_AMBULANCE) {\*\*

            \*\*DRes dveh = dijkstraAvoidBlocked(vehicles\\\[v].currentNode);\*\*

            \*\*if(dveh.dist\\\[inc.node] < bestDist){ bestDist = dveh.dist\\\[inc.node]; bestVeh = v; }\*\*

        \*\*}\*\*

        \*\*if(bestVeh!=-1) {\*\*

            \*\*vehicles\\\[bestVeh].available=false; vehicles\\\[bestVeh].destNode = inc.node; vehicles\\\[bestVeh].remainingDist = bestDist;\*\*

            \*\*char msg\\\[200]; snprintf(msg,200,"Auto-dispatch Ambulance %d to incident %d at node %d (ETA approx %d units)", vehicles\\\[bestVeh].id, inc.id, inc.node, bestDist/ max(1, vehicles\\\[bestVeh].speed));\*\*

            \*\*enqueueAlert(msg, inc.node, inc.severity, 0);\*\*

        \*\*}\*\*

        \*\*inc.handled = true;\*\*

    \*\*}\*\***



}

/* Simple linear prediction used by prevention function */
void predictFloodAdvance(int minsAhead, double predictedIncrease[]) {
    **\*\*for(int i=0;i<sensorsCount;i++) {\*\*

        \*\*double rainRate = sensors\\\[i].rainfall / 60.0; // mm/hr -> mm/min approx\*\*

        \*\*double riverRate = sensors\\\[i].riverLevel / 720.0;\*\*

        \*\*double inc = (rainRate \\\* minsAhead)/50.0 + (riverRate \\\* minsAhead)/200.0;\*\*

        \*\*predictedIncrease\\\[i] = inc;\*\*

    \*\*}\*\***



}

/* ---------------- Demo setup & run ---------------- */
void demoSetup() {
    **\*\*initGraph(12);\*\*

    \*\*addEdge(0,1,4); addEdge(1,2,6); addEdge(2,3,5); addEdge(3,4,3);\*\*

    \*\*addEdge(0,5,7); addEdge(5,6,3); addEdge(6,7,4); addEdge(7,4,6);\*\*

    \*\*addEdge(2,8,8); addEdge(8,9,5); addEdge(9,10,6); addEdge(10,11,4);\*\*

    \*\*// sensors\*\*

    \*\*addSensor(0, 30, 10, 0.3, 10, 5.0, 2000);\*\*

    \*\*addSensor(1, 60, 50, 0.5, 5, 2.0, 1200);\*\*

    \*\*addSensor(2, 120, 200, 0.8, 2, 1.0, 600);\*\*

    \*\*addSensor(3, 250, 300, 0.9, 1, 0.5, 300);\*\*

    \*\*addSensor(4, 20, 5, 0.2, 12, 6.0, 3000);\*\*

    \*\*addSensor(5, 10, 0, 0.1, 15, 10.0, 4000);\*\*

    \*\*addSensor(6, 80, 120, 0.7, 3, 1.5, 800);\*\*

    \*\*addSensor(7, 40, 30, 0.4, 8, 3.0, 1500);\*\*

    \*\*addSensor(8, 0, 0, 0.1, 20, 15.0, 5000);\*\*

    \*\*addSensor(9, 0, 0, 0.1, 18, 12.0, 4500);\*\*

    \*\*addSensor(10, 50, 80, 0.6, 4, 2.0, 700);\*\*

    \*\*addSensor(11, 10, 20, 0.3, 10, 7.0, 2000);\*\*

    \*\*// vehicles: ambulances, pumps\*\*

    \*\*addVehicle(401, VT\\\_AMBULANCE, 5, 4, 20);\*\*

    \*\*addVehicle(402, VT\\\_AMBULANCE, 6, 4, 18);\*\*

    \*\*addVehicle(501, VT\\\_PUMP, 0, 0, 0);\*\*

    \*\*addVehicle(502, VT\\\_PUMP, 2, 0, 0);\*\***



}

/* ---------------- main ---------------- */
int main() {
    **\*\*cout<<"=== Emergency Dispatch + Flood Prevention System ===\\\\n";\*\*

    \*\*demoSetup();\*\*

    \*\*int currentTime = 0;\*\*

    \*\*cout<<"\\\\n--- Preventative simulation step 1 ---\\\\n";\*\*

    \*\*simulationStepWithPrevention(currentTime);\*\*

    \*\*// simulate heavier rainfall after some time\*\*

    \*\*int idx = findSensorIdx(3); if(idx!=-1) { sensors\\\[idx].rainfall += 120; sensors\\\[idx].riverLevel += 90; }\*\*

    \*\*idx = findSensorIdx(2); if(idx!=-1) { sensors\\\[idx].rainfall += 80; sensors\\\[idx].riverLevel += 50; }\*\*

    \*\*currentTime += 60;\*\*

    \*\*cout<<"\\\\n--- Preventative simulation step 2 (after increased rainfall) ---\\\\n";\*\*

    \*\*simulationStepWithPrevention(currentTime);\*\*

    \*\*cout<<"\\\\nDemo complete.\\\\n";\*\*

    \*\*return 0;\*\***



}
`
  },
  housing: {
  title: 'Smart Housing Allocation System',
  desc: `
    <h3>Problem Statement</h3>
    <p>Manual housing allotment is slow, unfair, and inefficient.</p>

    <h3>System Approach</h3>
    <p>Applicants are stored in AVL Trees, prioritized using Max-Heaps, and houses are allocated based on cost and proximity.</p>

    <h3>Algorithms Used</h3>
    <p>AVL Tree, Max Heap, Min Heap, Dijkstra, Red-Black Tree, Merge Sort, KMP</p>

    <h3>ğŸ  Smart Housing Allocation System (Residential Zone)</h3>
    <ul>
      <li><b>Applicant Registry:</b> AVL Tree â€“ O(log n) insert/search with sorted applicant IDs</li>
      <li><b>Applicant Priority Queue:</b> Max-Heap â€“ allocates houses to most-needy applicants first</li>
      <li><b>House Inventory:</b> Min-Heap â€“ selects cheapest / best available house efficiently</li>
      <li><b>Proximity Evaluation:</b> Dijkstra (Adjacency Matrix) â€“ computes applicant-to-house distance</li>
      <li><b>Allocation Index:</b> Red-Black Tree â€“ maps ApplicantID â†’ HouseID without conflicts</li>
      <li><b>Applicant Sorting:</b> Merge Sort â€“ stable report generation</li>
      <li><b>Name Search:</b> KMP Algorithm â€“ fast partial applicant name lookup</li>
    </ul>

    <p><b>SDGs:</b> SDGâ€‘11, SDGâ€‘1, SDGâ€‘10</p>
  `,

    code:`#include <iostream>
#include <cstring>
#include <climits>
using namespace std;

/* ========== CONFIG ========== */
const int MAX_APPLICANTS = 300;
const int MAX_HOUSES = 200;
const int MAX_NODES = 40;   // graph nodes for city amenities
const int INF = 1000000000;

/* ========== DATA MODELS ========== */

// Applicant record
struct Applicant {
**Â    int id;                 // unique id**
**Â    char name[64];**
**Â    int familySize;**
**Â    double monthlyIncome;**
**Â    bool specialNeed;       // elderly/disabled**
**Â    int preferenceNode;     // preferred location (node)**
**Â    int score;              // computed priority score (higher = more urgent)**
};

// House record
struct House {
**Â    int id;**
**Â    int node;               // location node**
**Â    double price;**
**Â    double area;            // sq.ft**
**Â    bool available;**
};

/* ========== AVL TREE FOR APPLICANTS (by id) ========== */
struct AVLNode {
**Â    Applicant app;**
**Â    AVLNode *left, *right;**
**Â    int height;**
**Â    AVLNode(const Applicant &a): app(a), left(nullptr), right(nullptr), height(1) {}**
};

int avlHeight(AVLNode* n) { return n ? n->height : 0; }
AVLNode* avlRightRotate(AVLNode* y) {
**Â    AVLNode* x = y->left;**
**Â    AVLNode* T2 = x->right;**
**Â    x->right = y; y->left = T2;**
**Â    y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));**
**Â    x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));**
**Â    return x;**
}
AVLNode* avlLeftRotate(AVLNode* x) {
**Â    AVLNode* y = x->right;**
**Â    AVLNode* T2 = y->left;**
**Â    y->left = x; x->right = T2;**
**Â    x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));**
**Â    y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));**
**Â    return y;**
}
AVLNode* avlInsert(AVLNode* node, const Applicant &a) {
**Â    if (!node) return new AVLNode(a);**
**Â    if (a.id < node->app.id) node->left = avlInsert(node->left, a);**
**Â    else if (a.id > node->app.id) node->right = avlInsert(node->right, a);**
**Â    else return node; // duplicate ignored**
**Â    node->height = 1 + max(avlHeight(node->left), avlHeight(node->right));**
**Â    int balance = avlHeight(node->left) - avlHeight(node->right);**
**Â    if (balance > 1 && a.id < node->left->app.id) return avlRightRotate(node);**
**Â    if (balance < -1 && a.id > node->right->app.id) return avlLeftRotate(node);**
**Â    if (balance > 1 && a.id > node->left->app.id) { node->left = avlLeftRotate(node->left); return avlRightRotate(node); }**
**Â    if (balance < -1 && a.id < node->right->app.id) { node->right = avlRightRotate(node->right); return avlLeftRotate(node); }**
**Â    return node;**
}
AVLNode* avlSearch(AVLNode* root, int id) {
**Â    if (!root) return nullptr;**
**Â    if (id == root->app.id) return root;**
**Â    if (id < root->app.id) return avlSearch(root->left, id);**
**Â    return avlSearch(root->right, id);**
}

/* ========== MERGE SORT FOR APPLICANTS BY SCORE (array) ========== */
void mergeApplicants(Applicant arr[], int l, int m, int r) {
**Â    int n1 = m - l + 1, n2 = r - m;**
**Â    Applicant *L = new Applicant[n1];**
**Â    Applicant *R = new Applicant[n2];**
**Â    for (int i=0;i<n1;i++) L[i]=arr[l+i];**
**Â    for (int j=0;j<n2;j++) R[j]=arr[m+1+j];**
**Â    int i=0,j=0,k=l;**
**Â    while(i<n1 && j<n2) {**
**Â        if (L[i].score >= R[j].score) arr[k++] = L[i++]; // descending by score**
**Â        else arr[k++] = R[j++];**
**Â    }**
**Â    while(i<n1) arr[k++]=L[i++];**
**Â    while(j<n2) arr[k++]=R[j++];**
**Â    delete[] L; delete[] R;**
}
void mergeSortApplicants(Applicant arr[], int l, int r) {
**Â    if (l < r) {**
**Â        int m = (l + r)/2;**
**Â        mergeSortApplicants(arr, l, m);**
**Â        mergeSortApplicants(arr, m+1, r);**
**Â        mergeApplicants(arr, l, m, r);**
**Â    }**
}

/* ========== MAX-HEAP FOR APPLICANT PRIORITY (stores indices into applicants array) ========== */
struct ApplicantHeap {
**Â    int heapIdx[MAX_APPLICANTS];**
**Â    int size;**
**Â    ApplicantHeap(): size(0) {}**
**Â    void push(int idx, Applicant applicants[]) {**
**Â        heapIdx[size] = idx;**
**Â        int i = size++;**
**Â        while (i != 0) {**
**Â            int p = (i-1)/2;**
**Â            if (applicants[heapIdx[i]].score > applicants[heapIdx[p]].score) {**
**Â                int t = heapIdx[i]; heapIdx[i] = heapIdx[p]; heapIdx[p] = t;**
**Â                i = p;**
**Â            } else break;**
**Â        }**
**Â    }**
**Â    int pop(Applicant applicants[]) {**
**Â        if (size == 0) return -1;**
**Â        int root = heapIdx[0];**
**Â        heapIdx[0] = heapIdx[--size];**
**Â        // heapify**
**Â        int i=0;**
**Â        while(true) {**
**Â            int l=2*i+1, r=2*i+2, largest=i;**
**Â            if (l < size && applicants[heapIdx[l]].score > applicants[heapIdx[largest]].score) largest = l;**
**Â            if (r < size && applicants[heapIdx[r]].score > applicants[heapIdx[largest]].score) largest = r;**
**Â            if (largest != i) { int t = heapIdx[i]; heapIdx[i] = heapIdx[largest]; heapIdx[largest] = t; i = largest; }**
**Â            else break;**
**Â        }**
**Â        return root;**
**Â    }**
**Â    bool empty() { return size==0; }**
};

/* ========== MIN-HEAP FOR AVAILABLE HOUSES (choose cheapest or closest) ========== */
struct HouseHeap {
**Â    int heapIdx[MAX_HOUSES];**
**Â    int size;**
**Â    HouseHeap(): size(0) {}**
**Â    // comparator by price ascending; tie-breaker by area descending**
**Â    void push(int idx, House houses[]) {**
**Â        heapIdx[size] = idx;**
**Â        int i = size++;**
**Â        while (i != 0) {**
**Â            int p = (i-1)/2;**
**Â            bool better = (houses[heapIdx[i]].price < houses[heapIdx[p]].price) ||**
**Â                          (houses[heapIdx[i]].price == houses[heapIdx[p]].price && houses[heapIdx[i]].area > houses[heapIdx[p]].area);**
**Â            if (better) {**
**Â                int t = heapIdx[i]; heapIdx[i] = heapIdx[p]; heapIdx[p] = t;**
**Â                i = p;**
**Â            } else break;**
**Â        }**
**Â    }**
**Â    int pop(House houses[]) {**
**Â        if (size==0) return -1;**
**Â        int root = heapIdx[0];**
**Â        heapIdx[0] = heapIdx[--size];**
**Â        int i=0;**
**Â        while(true) {**
**Â            int l=2*i+1, r=2*i+2, smallest=i;**
**Â            if (l<size) {**
**Â                bool less = (houses[heapIdx[l]].price < houses[heapIdx[smallest]].price) ||**
**Â                            (houses[heapIdx[l]].price == houses[heapIdx[smallest]].price && houses[heapIdx[l]].area > houses[heapIdx[smallest]].area);**
**Â                if (less) smallest = l;**
**Â            }**
**Â            if (r<size) {**
**Â                bool less = (houses[heapIdx[r]].price < houses[heapIdx[smallest]].price) ||**
**Â                            (houses[heapIdx[r]].price == houses[heapIdx[smallest]].price && houses[heapIdx[r]].area > houses[heapIdx[smallest]].area);**
**Â                if (less) smallest = r;**
**Â            }**
**Â            if (smallest != i) { int t = heapIdx[i]; heapIdx[i] = heapIdx[smallest]; heapIdx[smallest] = t; i = smallest; }**
**Â            else break;**
**Â        }**
**Â        return root;**
**Â    }**
**Â    bool empty() { return size==0; }**
};

/* ========== RED-BLACK TREE FOR ALLOCATIONS (applicantID -> houseID) ========== */
enum Color { R_RED, R_BLACK };
struct RBTNode {
**Â    int appId;**
**Â    int houseId;**
**Â    Color color;**
**Â    RBTNode *left, *right, *parent;**
**Â    RBTNode(int a=0,int h=-1): appId(a), houseId(h), color(R_RED), left(nullptr), right(nullptr), parent(nullptr) {}**
};

class RBTree {
public:
**Â    RBTNode* root;**
**Â    RBTree(): root(nullptr) {}**
**Â    void rotateLeft(RBTNode* &rootRef, RBTNode* &pt) {**
**Â        RBTNode* pt_right = pt->right;**
**Â        pt->right = pt_right->left;**
**Â        if(pt->right) pt->right->parent = pt;**
**Â        pt_right->parent = pt->parent;**
**Â        if(!pt->parent) rootRef = pt_right;**
**Â        else if(pt == pt->parent->left) pt->parent->left = pt_right;**
**Â        else pt->parent->right = pt_right;**
**Â        pt_right->left = pt;**
**Â        pt->parent = pt_right;**
**Â    }**
**Â    void rotateRight(RBTNode* &rootRef, RBTNode* &pt) {**
**Â        RBTNode* pt_left = pt->left;**
**Â        pt->left = pt_left->right;**
**Â        if(pt->left) pt->left->parent = pt;**
**Â        pt_left->parent = pt->parent;**
**Â        if(!pt->parent) rootRef = pt_left;**
**Â        else if(pt == pt->parent->left) pt->parent->left = pt_left;**
**Â        else pt->parent->right = pt_left;**
**Â        pt_left->right = pt;**
**Â        pt->parent = pt_left;**
**Â    }**
**Â    void fixViolation(RBTNode* &rootRef, RBTNode* &pt) {**
**Â        RBTNode *parent_pt = nullptr, *grand_parent_pt = nullptr;**
**Â        while ((pt != rootRef) && (pt->color == R_RED) && (pt->parent->color == R_RED)) {**
**Â            parent_pt = pt->parent;**
**Â            grand_parent_pt = pt->parent->parent;**
**Â            if (parent_pt == grand_parent_pt->left) {**
**Â                RBTNode *uncle_pt = grand_parent_pt->right;**
**Â                if (uncle_pt && uncle_pt->color == R_RED) {**
**Â                    grand_parent_pt->color = R_RED;**
**Â                    parent_pt->color = R_BLACK;**
**Â                    uncle_pt->color = R_BLACK;**
**Â                    pt = grand_parent_pt;**
**Â                } else {**
**Â                    if (pt == parent_pt->right) {**
**Â                        rotateLeft(rootRef, parent_pt);**
**Â                        pt = parent_pt;**
**Â                        parent_pt = pt->parent;**
**Â                    }**
**Â                    rotateRight(rootRef, grand_parent_pt);**
**Â                    Color t = parent_pt->color; parent_pt->color = grand_parent_pt->color; grand_parent_pt->color = t;**
**Â                    pt = parent_pt;**
**Â                }**
**Â            } else {**
**Â                RBTNode *uncle_pt = grand_parent_pt->left;**
**Â                if (uncle_pt && uncle_pt->color == R_RED) {**
**Â                    grand_parent_pt->color = R_RED;**
**Â                    parent_pt->color = R_BLACK;**
**Â                    uncle_pt->color = R_BLACK;**
**Â                    pt = grand_parent_pt;**
**Â                } else {**
**Â                    if (pt == parent_pt->left) {**
**Â                        rotateRight(rootRef, parent_pt);**
**Â                        pt = parent_pt;**
**Â                        parent_pt = pt->parent;**
**Â                    }**
**Â                    rotateLeft(rootRef, grand_parent_pt);**
**Â                    Color t = parent_pt->color; parent_pt->color = grand_parent_pt->color; grand_parent_pt->color = t;**
**Â                    pt = parent_pt;**
**Â                }**
**Â            }**
**Â        }**
**Â        rootRef->color = R_BLACK;**
**Â    }**
**Â    void insert(int appId, int houseId) {**
**Â        RBTNode* pt = new RBTNode(appId, houseId);**
**Â        root = bstInsert(root, pt);**
**Â        fixViolation(root, pt);**
**Â    }**
**Â    RBTNode* bstInsert(RBTNode* rootLocal, RBTNode* pt) {**
**Â        if (!rootLocal) return pt;**
**Â        if (pt->appId < rootLocal->appId) {**
**Â            rootLocal->left = bstInsert(rootLocal->left, pt);**
**Â            rootLocal->left->parent = rootLocal;**
**Â        } else if (pt->appId > rootLocal->appId) {**
**Â            rootLocal->right = bstInsert(rootLocal->right, pt);**
**Â            rootLocal->right->parent = rootLocal;**
**Â        }**
**Â        return rootLocal;**
**Â    }**
**Â    int search(int appId) {**
**Â        RBTNode* cur = root;**
**Â        while(cur) {**
**Â            if (appId == cur->appId) return cur->houseId;**
**Â            if (appId < cur->appId) cur = cur->left;**
**Â            else cur = cur->right;**
**Â        }**
**Â        return -1; // not found**
**Â    }**
};

/* ========== DIJKSTRA (array adjacency matrix) ========== */
int nodeCount = 0;
int adjMat[MAX_NODES][MAX_NODES];

void initGraph(int n) {
**Â    nodeCount = n;**
**Â    for (int i=0;i<n;i++) for (int j=0;j<n;j++) adjMat[i][j] = (i==j?0:INF);**
}
void addEdgeGraph(int u,int v,int w) {
**Â    if (u<0||u>=nodeCount||v<0||v>=nodeCount) return;**
**Â    adjMat[u][v] = w; adjMat[v][u] = w;**
}
void dijkstra(int src, int dist[], int parent[]) {
**Â    bool used[MAX_NODES];**
**Â    for (int i=0;i<nodeCount;i++) { dist[i]=INF; parent[i]=-1; used[i]=false; }**
**Â    dist[src]=0;**
**Â    for (int it=0; it<nodeCount; ++it) {**
**Â        int u=-1, best=INF;**
**Â        for (int i=0;i<nodeCount;i++) if(!used[i] && dist[i]<best) { best=dist[i]; u=i; }**
**Â        if (u==-1) break;**
**Â        used[u]=true;**
**Â        for (int v=0; v<nodeCount; ++v) {**
**Â            if (adjMat[u][v] < INF && dist[u] + adjMat[u][v] < dist[v]) {**
**Â                dist[v] = dist[u] + adjMat[u][v];**
**Â                parent[v] = u;**
**Â            }**
**Â        }**
**Â    }**
}

/* ========== KMP FOR NAME SEARCH (C-style strings) ========== */
void computeLPS(const char pat[], int M, int lps[]) {
**Â    int len = 0; lps[0]=0; int i=1;**
**Â    while (i < M) {**
**Â        if (pat[i] == pat[len]) { len++; lps[i]=len; i++; }**
**Â        else { if (len != 0) len = lps[len-1]; else { lps[i]=0; i++; } }**
**Â    }**
}
bool KMPsearch(const char text[], const char pat[]) {
**Â    int N = strlen(text), M = strlen(pat);**
**Â    if (M==0) return true;**
**Â    int *lps = new int[M];**
**Â    computeLPS(pat, M, lps);**
**Â    int i=0,j=0;**
**Â    while(i<N) {**
**Â        if (text[i]==pat[j]) { i++; j++; if (j==M) { delete[] lps; return true; } }**
**Â        else { if (j) j = lps[j-1]; else i++; }**
**Â    }**
**Â    delete[] lps;**
**Â    return false;**
}

/* ========== SYSTEM STORAGE ========== */
Applicant applicants[MAX_APPLICANTS];
int applicantsCount = 0;

House houses[MAX_HOUSES];
int housesCount = 0;

AVLNode* applicantRoot = nullptr;
ApplicantHeap applicantHeap;
HouseHeap houseHeap;
RBTree allocationIndex;

/* ========== UTILITIES ========== */
int computeScore(const Applicant &a) {
**Â    // sample scoring: higher family size and lower income => higher priority**
**Â    int s = 0;**
**Â    s += a.familySize * 10;**
**Â    if (a.monthlyIncome < 15000) s += 80;**
**Â    else if (a.monthlyIncome < 30000) s += 40;**
**Â    if (a.specialNeed) s += 100;**
**Â    // proximity preference will be considered later when selecting house**
**Â    return s;**
}
void addApplicant(const Applicant &a) {
**Â    if (applicantsCount >= MAX_APPLICANTS) { cout<<"Applicant capacity reached\n"; return; }**
**Â    applicants[applicantsCount] = a;**
**Â    applicants[applicantsCount].score = computeScore(a);**
**Â    applicantRoot = avlInsert(applicantRoot, applicants[applicantsCount]);**
**Â    // push index into heap for allocation queue**
**Â    applicantHeap.push(applicantsCount, applicants);**
**Â    applicantsCount++;**
}
void addHouse(const House &h) {
**Â    if (housesCount >= MAX_HOUSES) { cout<<"House capacity reached\n"; return; }**
**Â    houses[housesCount] = h;**
**Â    houses[housesCount].available = h.available;**
**Â    if (houses[housesCount].available) houseHeap.push(housesCount, houses);**
**Â    housesCount++;**
}
void showTopApplicants(int k) {
**Â    // produce a shallow copy of heap (we'll pop from a temporary array)**
**Â    int tempHeap[MAX_APPLICANTS]; int sz=applicantHeap.size;**
**Â    for (int i=0;i<sz;i++) tempHeap[i]=applicantHeap.heapIdx[i];**
**Â    cout<<"Top applicants (id : score) :\n";**
**Â    for (int i=0;i<k && applicantHeap.size>0;i++) {**
**Â        int idx = applicantHeap.pop(applicants);**
**Â        cout<< applicants[idx].id << " : " << applicants[idx].score << "\n";**
**Â    }**
**Â    // restore heap**
**Â    for (int i=0;i<sz;i++) applicantHeap.heapIdx[i] = tempHeap[i];**
**Â    applicantHeap.size = sz;**
}

/* ========== ALLOCATION PROCESS ========== */
void allocateHousing() {
**Â    // process applicants in priority order (heap) and assign best available house**
**Â    while (!applicantHeap.empty() && !houseHeap.empty()) {**
**Â        int appIdx = applicantHeap.pop(applicants);**
**Â        Applicant &ap = applicants[appIdx];**
**Â        // evaluate available houses to find one closest to applicant preference (use Dijkstra distances)**
**Â        // We'll pop houses temporarily, compute a score combining price and distance, pick best, then push back others.**
**Â        int tempHIdx[MAX_HOUSES]; int tempCount=0;**
**Â        int bestHouseIdx = -1;**
**Â        double bestScore = 1e18; // lower better: price + alpha*distance**
**Â        double alpha = 1.0; // tuning param cost per distance unit**
**Â        // prepare distances from applicant preference node**
**Â        int dist[MAX_NODES], parent[MAX_NODES];**
**Â        dijkstra(ap.preferenceNode, dist, parent);**
**Â        // iterate through houseHeap positions -> but heap doesn't allow easy iterate; we'll pop houses and inspect**
**Â        while (!houseHeap.empty()) {**
**Â            int hIdx = houseHeap.pop(houses);**
**Â            tempHIdx[tempCount++] = hIdx;**
**Â            if (!houses[hIdx].available) continue;**
**Â            int hnode = houses[hIdx].node;**
**Â            int d = (hnode>=0 && hnode<nodeCount) ? dist[hnode] : INF;**
**Â            double score = houses[hIdx].price + alpha * ( (d>=INF)? 1000000 : d );**
**Â            // prefer houses nearer and cheaper**
**Â            if (score < bestScore) { bestScore = score; bestHouseIdx = hIdx; }**
**Â        }**
**Â        // Rebuild houseHeap from temp, skipping the assigned**
**Â        for (int i=0;i<tempCount;i++) {**
**Â            int idx = tempHIdx[i];**
**Â            if (idx == bestHouseIdx) continue; // assigned**
**Â            if (houses[idx].available) houseHeap.push(idx, houses);**
**Â        }**
**Â        if (bestHouseIdx == -1) {**
**Â            // no available house actually assignable, push applicant back? here we break**
**Â            cout<<"No suitable house available now for applicant "<<ap.id<<"\n";**
**Â            // optionally could queue applicant elsewhere; skip for now**
**Â            continue;**
**Â        }**
**Â        // assign**
**Â        houses[bestHouseIdx].available = false;**
**Â        allocationIndex.insert(ap.id, houses[bestHouseIdx].id);**
**Â        cout<<"Allocated Applicant "<<ap.id<<" ("<<ap.name<<") -> House "<<houses[bestHouseIdx].id<<"\n";**
**Â    }**
}

/* ========== DEMO SETUP & RUN ========== */
void setupDemoGraph() {
**Â    initGraph(8); // nodes 0..7**
**Â    addEdgeGraph(0,1,4); addEdgeGraph(0,2,6);**
**Â    addEdgeGraph(1,2,2); addEdgeGraph(1,3,7);**
**Â    addEdgeGraph(2,4,3); addEdgeGraph(3,4,2);**
**Â    addEdgeGraph(3,5,5); addEdgeGraph(4,6,4); addEdgeGraph(5,7,8);**
}
void setupDemoHouses() {
**Â    addHouse( (House){1001, 3, 4500.0, 900.0, true} );**
**Â    addHouse( (House){1002, 4, 5000.0, 1000.0, true} );**
**Â    addHouse( (House){1003, 2, 3500.0, 700.0, true} );**
**Â    addHouse( (House){1004, 6, 4800.0, 950.0, true} );**
}
void setupDemoApplicants() {
**Â    Applicant a1; a1.id=1; strcpy(a1.name,"Priya"); a1.familySize=4; a1.monthlyIncome=12000; a1.specialNeed=false; a1.preferenceNode=3;**
**Â    Applicant a2; a2.id=2; strcpy(a2.name,"Rajan"); a2.familySize=6; a2.monthlyIncome=8000; a2.specialNeed=true; a2.preferenceNode=4;**
**Â    Applicant a3; a3.id=3; strcpy(a3.name,"Leela"); a3.familySize=2; a3.monthlyIncome=35000; a3.specialNeed=false; a3.preferenceNode=2;**
**Â    Applicant a4; a4.id=4; strcpy(a4.name,"Suresh"); a4.familySize=5; a4.monthlyIncome=15000; a4.specialNeed=false; a4.preferenceNode=6;**
**Â    addApplicant(a1); addApplicant(a2); addApplicant(a3); addApplicant(a4);**
}

/* ========== MAIN ========== */
int main() {
**Â    cout<<"=== Smart Housing Allocation System (No vectors) ===\n\n";**

**Â    // Setup**
**Â    setupDemoGraph();**
**Â    setupDemoHouses();**
**Â    setupDemoApplicants();**

**Â    cout<<"\nTop applicants by priority (demo):\n";**
**Â    showTopApplicants(4);**

**Â    cout<<"\nStarting allocation process...\n";**
**Â    allocateHousing();**

**Â    cout<<"\nLookup allocation for applicant 2: House ID = " << allocationIndex.search(2) << "\n";**

**Â    // Search by name using KMP**
**Â    char pattern[] = "Leela";**
**Â    cout<<"\nSearching applicants by name pattern '"<<pattern<<"':\n";**
**Â    for (int i=0;i<applicantsCount;i++) {**
**Â        if (KMPsearch(applicants[i].name, pattern)) {**
**Â            cout<<"Found applicant: "<< applicants[i].id << " - " << applicants[i].name << "\n";**
**Â        }**
**Â    }**

**Â    // Report: sort applicants array by score for full listing**
**Â    cout<<"\nApplicants sorted by score (desc):\n";**
**Â    mergeSortApplicants(applicants, 0, applicantsCount-1);**
**Â    for (int i=0;i<applicantsCount;i++) {**
**Â        cout<< applicants[i].id << " " << applicants[i].name << " score=" << applicants[i].score << "\n";**
**Â    }**

**Â    cout<<"\nDemo complete.\n";**
**Â    return 0;**
}


`
  },
  market: {
  title: 'Smart Market & Commercial Zone Price Analyzer',
  desc: `
    <h3>Problem Statement</h3>
    <p>Unregulated pricing causes inflation spikes in commercial zones.</p>

    <h3>System Approach</h3>
    <p>Prices are tracked, sorted, and analyzed to detect abnormal increases and assist policy decisions.</p>

    <h3>Algorithms Used</h3>
    <p>Max Heap, Merge Sort, QuickSort, KMP, Rabinâ€“Karp, AVL Tree / BST</p>

    <h3>ğŸ“Š Smart Market & Commercial Zone Price Analyzer</h3>
    <ul>
      <li><b>Unstable Prices:</b> Merge Sort / QuickSort for daily price ordering; Max-Heap detects price spikes and fake inflation</li>
      <li><b>Data Manipulation:</b> KMP & Rabinâ€“Karp ensure accurate product search; AVL/BST maintains unique, tamper-proof records</li>
      <li><b>Market Zoning:</b> Separate zone-wise price lists (Wholesale, Retail, Import Yard) enable regulation and comparison</li>
      <li><b>Illegal Practices Detection:</b> Sorted zone comparison exposes overpricing, dumping, and tax evasion</li>
    </ul>

    <p><b>SDGs:</b> SDGâ€‘8, SDGâ€‘12, SDGâ€‘9</p>
  `,
    code:`#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;

// =====================================================
// 1. PRODUCT STRUCTURE
// =====================================================
struct Product {
**Â    char name[30];**
**Â    float price;**
};

// =====================================================
// 2. MERGE SORT (NO VECTORS, ONLY ARRAYS)
// =====================================================
void merge(Product arr[], int l, int m, int r) {
**Â    int n1 = m - l + 1, n2 = r - m;**

**Â    Product* L = new Product[n1];**
**Â    Product* R = new Product[n2];**

**Â    for (int i=0; i<n1; i++) L[i] = arr[l+i];**
**Â    for (int j=0; j<n2; j++) R[j] = arr[m+1+j];**

**Â    int i=0, j=0, k=l;**

**Â    while (i < n1 && j < n2) {**
**Â        if (L[i].price <= R[j].price) arr[k++] = L[i++];**
**Â        else arr[k++] = R[j++];**
**Â    }**
**Â    while (i<n1) arr[k++] = L[i++];**
**Â    while (j<n2) arr[k++] = R[j++];**

**Â    delete[] L;**
**Â    delete[] R;**
}

void mergeSort(Product arr[], int l, int r) {
**Â    if (l < r) {**
**Â        int m = (l+r)/2;**
**Â        mergeSort(arr, l, m);**
**Â        mergeSort(arr, m+1, r);**
**Â        merge(arr, l, m, r);**
**Â    }**
}

// =====================================================
// 3. QUICK SORT
// =====================================================
int partition(Product arr[], int low, int high) {
**Â    float pivot = arr[high].price;**
**Â    int i = low -1;**

**Â    for(int j=low; j<high; j++) {**
**Â        if(arr[j].price < pivot) {**
**Â            i++;**
**Â            Product temp = arr[i];**
**Â            arr[i] = arr[j];**
**Â            arr[j] = temp;**
**Â        }**
**Â    }**
**Â    Product temp = arr[i+1];**
**Â    arr[i+1] = arr[high];**
**Â    arr[high] = temp;**

**Â    return i+1;**
}

void quickSort(Product arr[], int low, int high) {
**Â    if(low < high) {**
**Â        int pi = partition(arr, low, high);**
**Â        quickSort(arr, low, pi-1);**
**Â        quickSort(arr, pi+1, high);**
**Â    }**
}

// =====================================================
// 4. MAX HEAP (NO VECTOR) â€“ PRICE SPIKE DETECTOR
// =====================================================
class MaxHeap {
public:
**Â    float heapArr[100];**
**Â    int size;**

**Â    MaxHeap() { size = 0; }**

**Â    void insert(float x) {**
**Â        int i = size;**
**Â        heapArr[size++] = x;**

**Â        while(i != 0 && heapArr[(i-1)/2] < heapArr[i]) {**
**Â            float temp = heapArr[i];**
**Â            heapArr[i] = heapArr[(i-1)/2];**
**Â            heapArr[(i-1)/2] = temp;**
**Â            i = (i-1)/2;**
**Â        }**
**Â    }**

**Â    float extractMax() {**
**Â        if (size <= 0) return -1;**

**Â        float root = heapArr[0];**
**Â        heapArr[0] = heapArr[size-1];**
**Â        size--;**
**Â        heapify(0);**
**Â        return root;**
**Â    }**

**Â    void heapify(int i) {**
**Â        int largest = i;**
**Â        int l = 2*i+1;**
**Â        int r = 2*i+2;**

**Â        if(l < size && heapArr[l] > heapArr[largest]) largest = l;**
**Â        if(r < size && heapArr[r] > heapArr[largest]) largest = r;**

**Â        if(largest != i) {**
**Â            float temp = heapArr[i];**
**Â            heapArr[i] = heapArr[largest];**
**Â            heapArr[largest] = temp;**
**Â            heapify(largest);**
**Â        }**
**Â    }**
};

// =====================================================
// 5. KMP STRING SEARCH - FIND PRODUCT BY NAME
// =====================================================
void computeLPS(char pat[], int M, int lps[]) {
**Â    int len = 0;**
**Â    lps[0] = 0;**
**Â    int i = 1;**

**Â    while(i < M) {**
**Â        if(pat[i] == pat[len]) {**
**Â            lps[i++] = ++len;**
**Â        } else {**
**Â            if(len != 0) len = lps[len-1];**
**Â            else lps[i++] = 0;**
**Â        }**
**Â    }**
}

int KMPSearch(char pat[], char txt[]) {
**Â    int M = strlen(pat);**
**Â    int N = strlen(txt);**

**Â    int* lps = new int[M];**
**Â    computeLPS(pat, M, lps);**

**Â    int i=0, j=0;**
**Â    while(i < N) {**
**Â        if(pat[j] == txt[i]) { i++; j++; }**
**Â        if(j == M) return 1;**
**Â        else if(i < N && pat[j] != txt[i]) {**
**Â            if(j != 0) j = lps[j-1];**
**Â            else i++;**
**Â        }**
**Â    }**
**Â    delete[] lps;**
**Â    return 0;**
}

// =====================================================
// 6. MAIN APPLICATION
// =====================================================
int main() {
**Â    cout << "\n=== SMART MARKET & COMMERCIAL ZONE PRICE ANALYZER ===\n";**

**Â    int n;**
**Â    cout << "Enter number of products: ";**
**Â    cin >> n;**

**Â    Product* arr = new Product[n];**

**Â    cout << "\nEnter Product Name & Price:\n";**
**Â    for(int i=0; i<n; i++) {**
**Â        cout << "Name: ";**
**Â        cin >> arr[i].name;**
**Â        cout << "Price: ";**
**Â        cin >> arr[i].price;**
**Â    }**

**Â    cout << "\nSorting using MERGE SORT...\n";**
**Â    mergeSort(arr, 0, n-1);**

**Â    cout << "\nSorted Price List (Low â†’ High):\n";**
**Â    for(int i=0; i<n; i++)**
**Â        cout << arr[i].name << " = Rs." << arr[i].price << endl;**

**Â    // ================== HEAP ALERT SYSTEM =====================**
**Â    MaxHeap priceHeap;**
**Â    for(int i=0; i<n; i++) priceHeap.insert(arr[i].price);**

**Â    float maxPrice = priceHeap.extractMax();**
**Â    cout << "\n*** ALERT: Highest Market Price Today = Rs." << maxPrice << " ***\n";**

**Â    // ================== NAME SEARCH ===========================**
**Â    char searchName[30];**
**Â    cout << "\nEnter item name to search: ";**
**Â    cin >> searchName;**

**Â    bool found = false;**
**Â    for(int i=0; i<n; i++) {**
**Â        if(KMPSearch(searchName, arr[i].name)) {**
**Â            cout << "FOUND â†’ " << arr[i].name << " at Rs." << arr[i].price << endl;**
**Â            found = true;**
**Â        }**
**Â    }**
**Â    if(!found) cout << "Item NOT FOUND.\n";**

**Â    delete[] arr;**
**Â    return 0;**
}

`
  },
  logistics: {
  title: 'Industrial Logistics & Supply Chain Manager',
  desc: `
    <h3>Problem Statement</h3>
    <p>Factory-to-warehouse movement is inefficient, especially for cold-chain goods.</p>

    <h3>System Approach</h3>
    <p>Warehouses are stored in AVL Trees, shipments prioritized with Heaps, and trucks dispatched using Dijkstra-based routing.</p>

    <h3>Algorithms Used</h3>
    <p>AVL Tree, Max Heap, Dijkstra, Bellmanâ€“Ford, Kruskal, Prim, Merge Sort, KMP, Greedy</p>

    <h3>ğŸšš Industrial Logistics & Supply Chain Manager</h3>
    <ul>
      <li><b>Warehouse Registry:</b> AVL Tree â€“ O(log n) lookup for cold-storage availability and capacity</li>
      <li><b>Shipment Priority:</b> Max-Heap â€“ assigns trucks to urgent and cold-chain shipments first</li>
      <li><b>Cold-Chain Monitoring:</b> Sensor data + Heap â€“ detect temperature deviations and trigger alerts</li>
      <li><b>Route Planning:</b> Dijkstra â€“ finds shortest-cost paths for pickup and delivery</li>
      <li><b>Penalty Routes:</b> Bellmanâ€“Ford â€“ handles traffic, toll, and cold-penalty adjustments</li>
      <li><b>Network Design:</b> Kruskal & Prim â€“ build minimal-cost logistics backbone</li>
      <li><b>Manifest Sorting:</b> Merge Sort â€“ generates stable, printable shipment reports</li>
      <li><b>Tracking Search:</b> KMP â€“ enables fast lookup of shipment tracking codes</li>
      <li><b>Truck Scheduling:</b> Greedy selection + Dijkstra â€“ choose nearest suitable truck</li>
      <li><b>Emergency Handling:</b> Alerts â€“ trigger shipment holds and rerouting to nearest cold warehouse</li>
    </ul>

    <p><b>SDGs:</b> SDGâ€‘8, SDGâ€‘9, SDGâ€‘12, SDGâ€‘13</p>
  `,

    code:`#include <bits/stdc++.h>
using namespace std;
const int MAX_NODES = 60;      // graph nodes
const int MAX_EDGES = 300;
const int MAX_WAREHOUSES = 200;
const int MAX_SHIPMENTS = 500;
const int MAX_TRUCKS = 80;
const int MAX_MANIFEST = 500;
const int INF = 1000000000;

/* ---------------- Graph / edges ---------------- */
struct Edge { int u,v,w; }; // w = time/cost
Edge edges[MAX_EDGES]; int edgesCount = 0;
int nodesCount = 0;
int adjMat[MAX_NODES][MAX_NODES]; // INF if no edge

void initGraph(int n) {
    **\*\*nodesCount = n; edgesCount = 0;\*\*

    \*\*for (int i=0;i<n;i++) for (int j=0;j<n;j++) adjMat\\\[i]\\\[j] = (i==j?0:INF);\*\***



}
void addEdge(int u,int v,int w) {
    **\*\*if(u<0||v<0||u>=nodesCount||v>=nodesCount) return;\*\*

    \*\*adjMat\\\[u]\\\[v] = w; adjMat\\\[v]\\\[u] = w;\*\*

    \*\*if (edgesCount < MAX\\\_EDGES) edges\\\[edgesCount++] = {u,v,w};\*\***



}

/* ---------------- AVL Tree: Warehouse registry ---------------- */
struct Warehouse {
    **\*\*int id;\*\*

    \*\*char name\\\[64];\*\*

    \*\*int node;           // graph node location\*\*

    \*\*bool coldStorage;   // has cold chain capacity\*\*

    \*\*int capacity;       // capacity in pallets\*\***



};
struct AVLNode {
    **\*\*Warehouse wh;\*\*

    \*\*AVLNode \\\*left, \\\*right;\*\*

    \*\*int height;\*\*

    \*\*AVLNode(const Warehouse \\\&w): wh(w), left(NULL), right(NULL), height(1) {}\*\***



};
int avlHeight(AVLNode* n) { return n? n->height : 0; }
AVLNode* rightRotate(AVLNode* y) {
    **\*\*AVLNode\\\* x = y->left; AVLNode\\\* T2 = x->right;\*\*

    \*\*x->right = y; y->left = T2;\*\*

    \*\*y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));\*\*

    \*\*x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));\*\*

    \*\*return x;\*\***



}
AVLNode* leftRotateA(AVLNode* x) {
    **\*\*AVLNode\\\* y = x->right; AVLNode\\\* T2 = y->left;\*\*

    \*\*y->left = x; x->right = T2;\*\*

    \*\*x->height = 1 + max(avlHeight(x->left), avlHeight(x->right));\*\*

    \*\*y->height = 1 + max(avlHeight(y->left), avlHeight(y->right));\*\*

    \*\*return y;\*\***



}
AVLNode* avlInsert(AVLNode* node, const Warehouse &w) {
    **\*\*if (!node) return new AVLNode(w);\*\*

    \*\*if (w.id < node->wh.id) node->left = avlInsert(node->left, w);\*\*

    \*\*else if (w.id > node->wh.id) node->right = avlInsert(node->right, w);\*\*

    \*\*else return node;\*\*

    \*\*node->height = 1 + max(avlHeight(node->left), avlHeight(node->right));\*\*

    \*\*int balance = avlHeight(node->left) - avlHeight(node->right);\*\*

    \*\*if (balance > 1 \\\&\\\& w.id < node->left->wh.id) return rightRotate(node);\*\*

    \*\*if (balance < -1 \\\&\\\& w.id > node->right->wh.id) return leftRotateA(node);\*\*

    \*\*if (balance > 1 \\\&\\\& w.id > node->left->wh.id) { node->left = leftRotateA(node->left); return rightRotate(node); }\*\*

    \*\*if (balance < -1 \\\&\\\& w.id < node->right->wh.id) { node->right = rightRotate(node->right); return leftRotateA(node); }\*\*

    \*\*return node;\*\***



}
AVLNode* warehouseRoot = NULL;
AVLNode* avlSearch(AVLNode* root, int id) {
    **\*\*if (!root) return NULL;\*\*

    \*\*if (id == root->wh.id) return root;\*\*

    \*\*if (id < root->wh.id) return avlSearch(root->left, id);\*\*

    \*\*return avlSearch(root->right, id);\*\***



}

/* ---------------- Shipments & Max-Heap priority ---------------- */
struct Shipment {
    **\*\*int id;\*\*

    \*\*char tracking\\\[48];  // tracking code\*\*

    \*\*int originNode;\*\*

    \*\*int destNode;\*\*

    \*\*int volume;         // pallets\*\*

    \*\*bool cold;          // needs cold-chain\*\*

    \*\*int priority;       // higher first\*\*

    \*\*bool dispatched;\*\***



};
Shipment shipments[MAX_SHIPMENTS]; int shipmentsCount = 0;
int shipmentHeap[MAX_SHIPMENTS]; int shipmentHeapSize = 0;

int computeShipmentPriority(const Shipment &s) {
    **\*\*int p = 0;\*\*

    \*\*p += s.volume \\\* 2;\*\*

    \*\*if (s.cold) p += 200;\*\*

    \*\*// earlier shipments get slightly higher due to insertion order (not stored here)\*\*

    \*\*return p;\*\***



}
void shipmentHeapPush(int idx) {
    **\*\*shipmentHeap\\\[shipmentHeapSize] = idx;\*\*

    \*\*int i = shipmentHeapSize++;\*\*

    \*\*while (i != 0) {\*\*

        \*\*int p = (i-1)/2;\*\*

        \*\*if (shipments\\\[shipmentHeap\\\[i]].priority > shipments\\\[shipmentHeap\\\[p]].priority) {\*\*

            \*\*int tmp = shipmentHeap\\\[i]; shipmentHeap\\\[i] = shipmentHeap\\\[p]; shipmentHeap\\\[p] = tmp;\*\*

            \*\*i = p;\*\*

        \*\*} else break;\*\*

    \*\*}\*\***



}
int shipmentHeapPop() {
    **\*\*if (shipmentHeapSize == 0) return -1;\*\*

    \*\*int root = shipmentHeap\\\[0];\*\*

    \*\*shipmentHeap\\\[0] = shipmentHeap\\\[--shipmentHeapSize];\*\*

    \*\*int i = 0;\*\*

    \*\*while (true) {\*\*

        \*\*int l = 2\\\*i+1, r = 2\\\*i+2, largest = i;\*\*

        \*\*if (l < shipmentHeapSize \\\&\\\& shipments\\\[shipmentHeap\\\[l]].priority > shipments\\\[shipmentHeap\\\[largest]].priority) largest = l;\*\*

        \*\*if (r < shipmentHeapSize \\\&\\\& shipments\\\[shipmentHeap\\\[r]].priority > shipments\\\[shipmentHeap\\\[largest]].priority) largest = r;\*\*

        \*\*if (largest != i) { int tmp = shipmentHeap\\\[i]; shipmentHeap\\\[i] = shipmentHeap\\\[largest]; shipmentHeap\\\[largest] = tmp; i = largest; }\*\*

        \*\*else break;\*\*

    \*\*}\*\*

    \*\*return root;\*\***



}

/* ---------------- Temperature sensors & Min-Heap for anomalies ---------------- */
struct TempSensor { int node; double tempC; double targetC; double deviation; };
TempSensor sensorsArr[MAX_NODES]; int sensorsArrCount = 0;
int tempHeap[MAX_NODES]; int tempHeapSize = 0; // max deviation at top? we want largest deviation -> use max-heap of deviation
void tempPush(int idx) {
    **\*\*tempHeap\\\[tempHeapSize] = idx;\*\*

    \*\*int i = tempHeapSize++;\*\*

    \*\*while (i!=0) {\*\*

        \*\*int p=(i-1)/2;\*\*

        \*\*if (sensorsArr\\\[tempHeap\\\[i]].deviation > sensorsArr\\\[tempHeap\\\[p]].deviation) { int t=tempHeap\\\[i]; tempHeap\\\[i]=tempHeap\\\[p]; tempHeap\\\[p]=t; i=p; } else break;\*\*

    \*\*}\*\***



}
int tempPop() {
    **\*\*if (tempHeapSize==0) return -1;\*\*

    \*\*int root = tempHeap\\\[0];\*\*

    \*\*tempHeap\\\[0] = tempHeap\\\[--tempHeapSize];\*\*

    \*\*int i=0;\*\*

    \*\*while(true) {\*\*

        \*\*int l=2\\\*i+1, r=2\\\*i+2, largest=i;\*\*

        \*\*if (l<tempHeapSize \\\&\\\& sensorsArr\\\[tempHeap\\\[l]].deviation > sensorsArr\\\[tempHeap\\\[largest]].deviation) largest=l;\*\*

        \*\*if (r<tempHeapSize \\\&\\\& sensorsArr\\\[tempHeap\\\[r]].deviation > sensorsArr\\\[tempHeap\\\[largest]].deviation) largest=r;\*\*

        \*\*if (largest!=i) { int t=tempHeap\\\[i]; tempHeap\\\[i]=tempHeap\\\[largest]; tempHeap\\\[largest]=t; i=largest; } else break;\*\*

    \*\*}\*\*

    \*\*return root;\*\***



}

/* ---------------- Trucks ---------------- */
struct Truck { int id; int node; int capacity; int load; bool available; int speed; };
Truck trucks[MAX_TRUCKS]; int trucksCount = 0;
void addTruck(int id,int node,int cap,int speed) {
    **\*\*if(trucksCount>=MAX\\\_TRUCKS) return;\*\*

    \*\*trucks\\\[trucksCount].id=id; trucks\\\[trucksCount].node=node; trucks\\\[trucksCount].capacity=cap; trucks\\\[trucksCount].load=0; trucks\\\[trucksCount].available=true; trucks\\\[trucksCount].speed=speed;\*\*

    \*\*trucksCount++;\*\***



}

/* ---------------- Dijkstra (array-based) ---------------- */
struct DRes { int dist[MAX_NODES]; int parent[MAX_NODES]; };
DRes dijkstra(int src) {
    **\*\*DRes R; bool used\\\[MAX\\\_NODES];\*\*

    \*\*for(int i=0;i<nodesCount;i++){ R.dist\\\[i]=INF; R.parent\\\[i]=-1; used\\\[i]=false; }\*\*

    \*\*R.dist\\\[src]=0;\*\*

    \*\*for(int iter=0; iter<nodesCount; ++iter) {\*\*

        \*\*int u=-1, best=INF;\*\*

        \*\*for(int i=0;i<nodesCount;i++) if(!used\\\[i] \\\&\\\& R.dist\\\[i] < best){ best=R.dist\\\[i]; u=i; }\*\*

        \*\*if(u==-1) break;\*\*

        \*\*used\\\[u]=true;\*\*

        \*\*for(int v=0; v<nodesCount; ++v) if(adjMat\\\[u]\\\[v] < INF \\\&\\\& R.dist\\\[u]+adjMat\\\[u]\\\[v] < R.dist\\\[v]) {\*\*

            \*\*R.dist\\\[v] = R.dist\\\[u] + adjMat\\\[u]\\\[v];\*\*

            \*\*R.parent\\\[v] = u;\*\*

        \*\*}\*\*

    \*\*}\*\*

    \*\*return R;\*\***



}

/* ---------------- Bellman-Ford for penalty-weighted edges (e.g., traffic or cold-penalty) ---------------- */
bool bellmanFord(int src, int dist[]) {
    **\*\*for(int i=0;i<nodesCount;i++) dist\\\[i]=INF;\*\*

    \*\*dist\\\[src]=0;\*\*

    \*\*for(int k=0;k<nodesCount-1;k++) {\*\*

        \*\*bool changed=false;\*\*

        \*\*for(int e=0;e<edgesCount;e++){\*\*

            \*\*int u=edges\\\[e].u, v=edges\\\[e].v, w=edges\\\[e].w;\*\*

            \*\*if(dist\\\[u] < INF \\\&\\\& dist\\\[u]+w < dist\\\[v]) { dist\\\[v]=dist\\\[u]+w; changed=true; }\*\*

            \*\*if(dist\\\[v] < INF \\\&\\\& dist\\\[v]+w < dist\\\[u]) { dist\\\[u]=dist\\\[v]+w; changed=true; }\*\*

        \*\*}\*\*

        \*\*if(!changed) break;\*\*

    \*\*}\*\*

    \*\*return true;\*\***



}

/* ---------------- Kruskal & Prim for network design (MST) ---------------- */
int parentUF[MAX_NODES], rankUF[MAX_NODES];
void ufInit(int n){ for(int i=0;i<n;i++){ parentUF[i]=i; rankUF[i]=0; } }
int ufFind(int x){ return parentUF[x]==x?x:parentUF[x]=ufFind(parentUF[x]); }
void ufUnion(int a,int b){ a=ufFind(a); b=ufFind(b); if(a==b) return; if(rankUF[a]<rankUF[b]) parentUF[a]=b; else if(rankUF[b]<rankUF[a]) parentUF[b]=a; else { parentUF[b]=a; rankUF[a]++; } }

void sortEdges(Edge arr[], int n) {
    **\*\*if(n<=1) return;\*\*

    \*\*int m=n/2;\*\*

    \*\*Edge \\\*L = new Edge\\\[m], \\\*R = new Edge\\\[n-m];\*\*

    \*\*for(int i=0;i<m;i++) L\\\[i]=arr\\\[i];\*\*

    \*\*for(int i=0;i<n-m;i++) R\\\[i]=arr\\\[m+i];\*\*

    \*\*sortEdges(L,m); sortEdges(R,n-m);\*\*

    \*\*int i=0,j=0,k=0;\*\*

    \*\*while(i<m \\\&\\\& j<n-m) arr\\\[k++] = (L\\\[i].w <= R\\\[j].w ? L\\\[i++] : R\\\[j++]);\*\*

    \*\*while(i<m) arr\\\[k++]=L\\\[i++]; while(j<n-m) arr\\\[k++]=R\\\[j++];\*\*

    \*\*delete\\\[] L; delete\\\[] R;\*\***



}
int kruskalMST(Edge out[]) {
    **\*\*Edge tmp\\\[MAX\\\_EDGES];\*\*

    \*\*for(int i=0;i<edgesCount;i++) tmp\\\[i]=edges\\\[i];\*\*

    \*\*sortEdges(tmp, edgesCount);\*\*

    \*\*ufInit(nodesCount); int outCount=0;\*\*

    \*\*for(int i=0;i<edgesCount \\\&\\\& outCount < nodesCount-1;i++){\*\*

        \*\*int u=tmp\\\[i].u, v=tmp\\\[i].v;\*\*

        \*\*if(ufFind(u) != ufFind(v)) { ufUnion(u,v); out\\\[outCount++] = tmp\\\[i]; }\*\*

    \*\*}\*\*

    \*\*return 0;\*\***



}
int primMSTParent[MAX_NODES];
int primMST() {
    **\*\*bool inMST\\\[MAX\\\_NODES]; int key\\\[MAX\\\_NODES];\*\*

    \*\*for(int i=0;i<nodesCount;i++){ inMST\\\[i]=false; key\\\[i]=INF; primMSTParent\\\[i]=-1; }\*\*

    \*\*key\\\[0]=0;\*\*

    \*\*for(int cnt=0; cnt<nodesCount; ++cnt) {\*\*

        \*\*int u=-1, best=INF;\*\*

        \*\*for(int i=0;i<nodesCount;i++) if(!inMST\\\[i] \\\&\\\& key\\\[i] < best){ best=key\\\[i]; u=i; }\*\*

        \*\*if(u==-1) break;\*\*

        \*\*inMST\\\[u]=true;\*\*

        \*\*for(int v=0; v<nodesCount; ++v) if(adjMat\\\[u]\\\[v] < INF \\\&\\\& !inMST\\\[v] \\\&\\\& adjMat\\\[u]\\\[v] < key\\\[v]) { key\\\[v]=adjMat\\\[u]\\\[v]; primMSTParent\\\[v]=u; }\*\*

    \*\*}\*\*

    \*\*int cost=0; for(int i=1;i<nodesCount;i++) if(primMSTParent\\\[i]!=-1) cost += adjMat\\\[i]\\\[primMSTParent\\\[i]];\*\*

    \*\*return cost;\*\***



}

/* ---------------- Manifest sorting (Merge Sort) ---------------- */
struct ManifestItem { int shipmentId; char desc[80]; int priority; };
ManifestItem manifest[MAX_MANIFEST]; int manifestSize=0;
void mergeManifest(int l,int m,int r) {
    **\*\*int n1=m-l+1, n2=r-m;\*\*

    \*\*ManifestItem \\\*L = new ManifestItem\\\[n1]; ManifestItem \\\*R = new ManifestItem\\\[n2];\*\*

    \*\*for(int i=0;i<n1;i++) L\\\[i]=manifest\\\[l+i];\*\*

    \*\*for(int j=0;j<n2;j++) R\\\[j]=manifest\\\[m+1+j];\*\*

    \*\*int i=0,j=0,k=l;\*\*

    \*\*while(i<n1 \\\&\\\& j<n2) {\*\*

        \*\*if(L\\\[i].priority >= R\\\[j].priority) manifest\\\[k++]=L\\\[i++]; else manifest\\\[k++]=R\\\[j++];\*\*

    \*\*}\*\*

    \*\*while(i<n1) manifest\\\[k++]=L\\\[i++]; while(j<n2) manifest\\\[k++]=R\\\[j++];\*\*

    \*\*delete\\\[] L; delete\\\[] R;\*\***



}
void mergeSortManifest(int l,int r){ if(l<r){ int m=(l+r)/2; mergeSortManifest(l,m); mergeSortManifest(m+1,r); mergeManifest(l,m,r); } }

/* ---------------- KMP for tracking code search ---------------- */
void computeLPS(const char pat[], int M, int lps[]) {
    **\*\*int len=0; lps\\\[0]=0; int i=1;\*\*

    \*\*while(i<M) {\*\*

        \*\*if(pat\\\[i]==pat\\\[len]) { len++; lps\\\[i]=len; i++; }\*\*

        \*\*else { if(len!=0) len=lps\\\[len-1]; else { lps\\\[i]=0; i++; } }\*\*

    \*\*}\*\***



}
bool KMPsearch(const char txt[], const char pat[]) {
    **\*\*int N=strlen(txt), M=strlen(pat);\*\*

    \*\*if(M==0) return true;\*\*

    \*\*int \\\*lps = new int\\\[M];\*\*

    \*\*computeLPS(pat,M,lps);\*\*

    \*\*int i=0,j=0;\*\*

    \*\*while(i<N) {\*\*

        \*\*if(txt\\\[i]==pat\\\[j]) { i++; j++; if(j==M){ delete\\\[] lps; return true; } }\*\*

        \*\*else { if(j) j=lps\\\[j-1]; else i++; }\*\*

    \*\*}\*\*

    \*\*delete\\\[] lps; return false;\*\***



}

/* ---------------- Utility: add demo data ---------------- */
AVLNode* whRoot = NULL;
void addWarehouse(int id,const char* name,int node,bool cold,int cap) {
    **\*\*Warehouse w; w.id=id; strncpy(w.name,name,63); w.name\\\[63]=0; w.node=node; w.coldStorage=cold; w.capacity=cap;\*\*

    \*\*whRoot = avlInsert(whRoot, w);\*\***



}
void addShipment(int id,const char* code,int o,int d,int vol,bool cold) {
    **\*\*if(shipmentsCount>=MAX\\\_SHIPMENTS) return;\*\*

    \*\*shipments\\\[shipmentsCount].id=id; strncpy(shipments\\\[shipmentsCount].tracking,code,47); shipments\\\[shipmentsCount].tracking\\\[47]=0;\*\*

    \*\*shipments\\\[shipmentsCount].originNode=o; shipments\\\[shipmentsCount].destNode=d; shipments\\\[shipmentsCount].volume=vol; shipments\\\[shipmentsCount].cold=cold;\*\*

    \*\*shipments\\\[shipmentsCount].priority = computeShipmentPriority(shipments\\\[shipmentsCount]);\*\*

    \*\*shipments\\\[shipmentsCount].dispatched = false;\*\*

    \*\*shipmentHeapPush(shipmentsCount);\*\*

    \*\*// manifest add\*\*

    \*\*if(manifestSize < MAX\\\_MANIFEST) { manifest\\\[manifestSize].shipmentId = id; snprintf(manifest\\\[manifestSize].desc,79,"Shipment %d code %s", id, code); manifest\\\[manifestSize].priority = shipments\\\[shipmentsCount].priority; manifestSize++; }\*\*

    \*\*shipmentsCount++;\*\***



}
void addTempSensor(int node,double temp,double target) {
    **\*\*if(sensorsArrCount >= MAX\\\_NODES) return;\*\*

    \*\*sensorsArr\\\[sensorsArrCount].node = node; sensorsArr\\\[sensorsArrCount].tempC = temp; sensorsArr\\\[sensorsArrCount].targetC = target;\*\*

    \*\*sensorsArr\\\[sensorsArrCount].deviation = fabs(temp - target);\*\*

    \*\*tempPush(sensorsArrCount);\*\*

    \*\*sensorsArrCount++;\*\***



}

/* ---------------- Scheduling & Dispatch simulation ---------------- */
void dispatchNextShipment() {
    **\*\*int idx = shipmentHeapPop();\*\*

    \*\*if(idx == -1) { cout<<"No shipments to dispatch\\\\n"; return; }\*\*

    \*\*Shipment \\\&s = shipments\\\[idx];\*\*

    \*\*// choose best truck: available and capacity >= volume and if cold required, prefer trucks with cold capability (not modeled separately here)\*\*

    \*\*int bestTruck = -1, bestDist = INF;\*\*

    \*\*for(int t=0;t<trucksCount;t++) {\*\*

        \*\*if(!trucks\\\[t].available) continue;\*\*

        \*\*if(trucks\\\[t].capacity < s.volume) continue;\*\*

        \*\*DRes dr = dijkstra(trucks\\\[t].node);\*\*

        \*\*if(dr.dist\\\[s.originNode] < bestDist) { bestDist = dr.dist\\\[s.originNode]; bestTruck = t; }\*\*

    \*\*}\*\*

    \*\*if(bestTruck == -1) { cout<<"No available truck for shipment "<<s.id<<", requeueing\\\\n"; s.priority = max(0, s.priority-5); shipmentHeapPush(idx); return; }\*\*

    \*\*// simulate pickup + route to destination (compute path)\*\*

    \*\*DRes drOrigin = dijkstra(s.originNode);\*\*

    \*\*int distToDest = drOrigin.dist\\\[s.destNode];\*\*

    \*\*cout<<"Dispatch: Truck "<<trucks\\\[bestTruck].id<<" assigned to shipment "<<s.id<<" (origin "<<s.originNode<<" -> dest "<<s.destNode<<", dist="<<distToDest<<")\\\\n";\*\*

    \*\*// mark truck busy\*\*

    \*\*trucks\\\[bestTruck].available = false;\*\*

    \*\*trucks\\\[bestTruck].load = s.volume;\*\*

    \*\*// after dispatch mark shipment dispatched (in real sim we'd move truck)\*\*

    \*\*s.dispatched = true;\*\***



}

/* ---------------- Temperature anomaly handling for cold chain ---------------- */
void handleTemperatureAnomalies() {
    **\*\*// pop top sensors with largest deviation and create alerts / reroute shipments if needed\*\*

    \*\*int top = tempPop();\*\*

    \*\*while(top != -1) {\*\*

        \*\*TempSensor \\\&ts = sensorsArr\\\[top];\*\*

        \*\*if (ts.deviation > 2.0) { // degrees C threshold\*\*

            \*\*cout<<"\\\[TEMP ALERT] Node "<<ts.node<<" temp="<<ts.tempC<<" target="<<ts.targetC<<" dev="<<ts.deviation<<"\\\\n";\*\*

            \*\*// find shipments in transit to node -> we will scan shipments array and flag re-route (simple)\*\*

            \*\*for(int i=0;i<shipmentsCount;i++) {\*\*

                \*\*if(shipments\\\[i].dispatched \\\&\\\& shipments\\\[i].destNode == ts.node \\\&\\\& shipments\\\[i].cold) {\*\*

                    \*\*cout<<"  -> Cold-chain shipment "<<shipments\\\[i].id<<" destined to node "<<ts.node<<" flagged for emergency reroute/hold.\\\\n";\*\*

                    \*\*// in real system: hold at nearest cold warehouse\*\*

                \*\*}\*\*

            \*\*}\*\*

        \*\*}\*\*

        \*\*top = tempPop();\*\*

    \*\*}\*\***



}

/* ---------------- Demo & run ---------------- */
void buildDemo() {
    **\*\*initGraph(12);\*\*

    \*\*addEdge(0,1,5); addEdge(1,2,6); addEdge(2,3,8); addEdge(0,4,7);\*\*

    \*\*addEdge(4,5,3); addEdge(5,6,5); addEdge(6,7,4); addEdge(3,8,7);\*\*

    \*\*addEdge(7,9,6); addEdge(9,10,5); addEdge(10,11,4);\*\*

    \*\*// warehouses\*\*

    \*\*addWarehouse(101,"MainColdHub",2,true,200);\*\*

    \*\*addWarehouse(102,"ZoneA\\\_WH",5,true,80);\*\*

    \*\*addWarehouse(103,"ZoneB\\\_WH",9,false,150);\*\*

    \*\*// trucks\*\*

    \*\*addTruck(201,0,100,60); addTruck(202,4,80,50); addTruck(203,6,120,55);\*\*

    \*\*// temp sensors (some nodes have sensors)\*\*

    \*\*addTempSensor(2, -2.5, -4.0); // colder than target (e.g., freezer too warm?)\*\*

    \*\*addTempSensor(5, 2.0, 2.0);\*\*

    \*\*addTempSensor(9, 5.0, 2.0); // big deviation\*\*

    \*\*// shipments (some cold)\*\*

    \*\*addShipment(301,"COLD-AX1",2,9,30,true);\*\*

    \*\*addShipment(302,"NORM-23B",4,11,50,false);\*\*

    \*\*addShipment(303,"COLD-BX2",5,2,20,true);\*\*

    \*\*// manifest sort demo\*\*

    \*\*mergeSortManifest(0, manifestSize-1);\*\***



}

/* ---------------- Main ---------------- */
int main() {
    **\*\*cout<<"=== Industrial Logistics \\\& Cold-Chain Manager ===\\\\n";\*\*

    \*\*buildDemo();\*\*

    \*\*cout<<"\\\\n-- Dispatching highest priority shipments --\\\\n";\*\*

    \*\*dispatchNextShipment();\*\*

    \*\*dispatchNextShipment();\*\*

    \*\*cout<<"\\\\n-- Checking temperature anomalies \\\& cold-chain alerts --\\\\n";\*\*

    \*\*handleTemperatureAnomalies();\*\*

    \*\*cout<<"\\\\n-- Network planner: Prim MST cost --\\\\n";\*\*

    \*\*int cost = primMST();\*\*

    \*\*cout<<"Prim MST total cost (approx): "<<cost<<"\\\\n";\*\*

    \*\*cout<<"\\\\n-- Search shipments by tracking substring 'AX1' (KMP) --\\\\n";\*\*

    \*\*for(int i=0;i<shipmentsCount;i++) if(KMPsearch(shipments\\\[i].tracking, "AX1")) cout<<"Found shipment id "<<shipments\\\[i].id<<" code "<<shipments\\\[i].tracking<<"\\\\n";\*\*

    \*\*cout<<"\\\\nDemo complete.\\\\n";\*\*

    \*\*return 0;\*\***



}
`
  }
};

function openModal(key){
  document.getElementById('modal').style.display='flex';
  document.getElementById('title').innerText=data[key].title;
  document.getElementById('desc').innerHTML=data[key].desc;
  document.getElementById('code').innerText=data[key].code;
  document.getElementById('code').style.display='none';
}
function closeModal(){document.getElementById('modal').style.display='none'}
function toggleCode(){const c=document.getElementById('code');c.style.display=c.style.display==='none'?'block':'none'}
</script>
</body>
</html>
