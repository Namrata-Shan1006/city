<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Namrata | Bellasagaram Team</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body data-theme="light">

  <header class="header">
    <nav class="navbar">
      <div class="logo">Bellasagaram</div>
      <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
        <span class="sun">‚òÄÔ∏è</span>
        <span class="moon">üåô</span>
      </button>
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="project.html">Project</a></li>
        <li><a href="anoosha.html">Anoosha</a></li>
        <li><a href="namrata.html" class="active">Namrata</a></li>
        <li><a href="sonika.html">Sonika</a></li>
        <li><a href="collabz.html">Collabz</a></li>
      </ul>
    </nav>
  </header>

  <button id="backToTop" class="back-to-top" aria-label="Back to top">‚Üë</button>

  <main>
    <section class="member-section section-wrapper">
      <div class="member-header">
        <button class="back-btn" onclick="history.back()">‚Üê Back</button>
        <h1 class="section-heading">Namrata Shanbhag</h1>
      </div>

      <div class="member-card glass-card">
        <p><strong>Roll:</strong> 227</p>
        <p><strong>USN:</strong> 01FE24BCS101</p>
        <p><strong>Role in Project:</strong> Documentation &amp; Analysis</p>

        <h2>Business Ideas</h2>

        <!-- GRID OF SQUARE IDEA BOXES -->
        <div class="ideas-grid-nam">

          <!-- 1. Smart Surveillance -->
          <div class="idea-box">
            <h3>üé• Smart Surveillance &amp; CCTV Command Center</h3>
            <p class="idea-desc">
              A central dashboard that receives alerts from all CCTV cameras across the city and
              prioritizes them based on severity and time, so emergencies are handled first.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Priority Queue (Min-Heap) for alert handling
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Alerts (fire, accident, intrusion, traffic) must be processed in
              order of importance and timestamp. A priority queue always gives the highest priority
              alert in <code>O(log n)</code> time.
            </p>
            <pre class="idea-code"><code>// Insert an alert into min-heap by priority
void push(int heap[], int *n, int value) {
    int i = ++(*n);
    heap[i] = value;
    while (i > 1 && heap[i/2] &gt; heap[i]) {
        int temp = heap[i];
        heap[i] = heap[i/2];
        heap[i/2] = temp;
        i /= 2;
    }
}</code></pre>
          </div>

          <!-- 2. GPS Tracking -->
          <div class="idea-box">
            <h3>üöì GPS Tracking &amp; Fleet Management for Police Vehicles</h3>
            <p class="idea-desc">
              Tracks all police vehicles and guides them through the shortest and fastest paths
              to reach crime spots or emergencies inside Bellasagaram.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Dijkstra&apos;s Shortest Path Algorithm
            </p>
            <p class="idea-why">
              <strong>Why?</strong> The city road network can be modeled as a weighted graph where
              weights are travel time or distance. Dijkstra&apos;s algorithm finds the minimum cost path
              from the control center to any destination node.
            </p>
            <pre class="idea-code"><code>// Dijkstra's algorithm (adjacency matrix)
int minDist(int dist[], int visited[], int n) {
    int min = 1e9, idx = -1;
    for (int i = 0; i &lt; n; i++)
        if (!visited[i] &amp;&amp; dist[i] &lt; min) { min = dist[i]; idx = i; }
    return idx;
}</code></pre>
          </div>

          <!-- 3. Sewage Treatment Plant -->
          <div class="idea-box">
            <h3>üíß Sewage Treatment Plant (STP) Operation &amp; Maintenance</h3>
            <p class="idea-desc">
              Schedules maintenance tasks, sensor checks, and cleaning cycles so that the STP
              runs continuously without breakdown and meets environmental standards.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Greedy Scheduling by Earliest Deadline / Priority
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Maintenance jobs with earlier deadlines or higher priority
              must be executed first to avoid overflow or failure. A greedy approach sorts tasks
              by deadline/priority and picks them in that order.
            </p>
            <pre class="idea-code"><code>// Sort jobs by deadline using a simple bubble sort
void sortByDeadline(int d[], int p[], int n) {
    for (int i = 0; i &lt; n-1; i++)
        for (int j = 0; j &lt; n-1-i; j++)
            if (d[j] &gt; d[j+1]) {
                int td = d[j]; d[j] = d[j+1]; d[j+1] = td;
                int tp = p[j]; p[j] = p[j+1]; p[j+1] = tp;
            }
}</code></pre>
          </div>

          <!-- 4. Smart Pedestrian & Cycle Tracks -->
          <div class="idea-box">
            <h3>üö∂‚Äç‚ôÄÔ∏è Smart Pedestrian &amp; Cycle Tracks</h3>
            <p class="idea-desc">
              Designs safe walking and cycling routes inside the city, avoiding high-traffic roads,
              and suggesting shortest paths through dedicated tracks.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> BFS (Breadth-First Search) on Unweighted Grid Graph
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Tracks can be represented as an unweighted grid. BFS always finds
              the shortest path in terms of number of edges when all edges have equal weight.
            </p>
            <pre class="idea-code"><code>// BFS to find shortest steps on grid (concept)
void bfs(int start) {
    int q[1000], front = 0, rear = 0;
    int visited[100] = {0};
    q[rear++] = start; visited[start] = 1;
    while (front &lt; rear) {
        int u = q[front++];
        // visit all neighbours v of u
    }
}</code></pre>
          </div>

          <!-- 5. Public Utilities -->
          <div class="idea-box">
            <h3>üí° Public Utilities: Billing, Meter Reading, Water Distribution</h3>
            <p class="idea-desc">
              Manages automatic meter readings, fair billing, and balanced water flow across
              different city zones based on demand and supply.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Greedy Load Balancing + Binary Search for Slab Billing
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Billing uses slab ranges (0‚Äì50 units, 51‚Äì100, etc.). Binary search
              quickly identifies the correct slab; greedy distribution balances total supply across zones.
            </p>
            <pre class="idea-code"><code>// Find slab index for units using binary search
int findSlab(int slabs[], int n, int units) {
    int l = 0, r = n-1, ans = n-1;
    while (l &lt;= r) {
        int mid = (l + r)/2;
        if (units &lt;= slabs[mid]) {
            ans = mid;
            r = mid - 1;
        } else l = mid + 1;
    }
    return ans;
}</code></pre>
          </div>

          <!-- 6. Foreign Exchange & Remittance Centre -->
          <div class="idea-box">
            <h3>üí± Foreign Exchange &amp; Remittance Centre</h3>
            <p class="idea-desc">
              Helps citizens and tourists convert currencies at the best rate and sends money
              between different Bellasagaram zones and banks securely.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Bellman‚ÄìFord for Best Exchange Paths &amp; Arbitrage Detection
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Exchange rates can be modeled as weighted directed edges between
              currencies. Bellman‚ÄìFord handles negative weights (log of rates) and can detect
              profitable cycles (arbitrage).
            </p>
            <pre class="idea-code"><code>// Relax edges (u,v) with weight w in Bellman-Ford
void relax(int u, int v, int w, int dist[]) {
    if (dist[u] != 1e9 &amp;&amp; dist[u] + w &lt; dist[v])
        dist[v] = dist[u] + w;
}</code></pre>
          </div>

          <!-- 7. Tax & Accounting Service -->
          <div class="idea-box">
            <h3>üìä Tax &amp; Accounting Service</h3>
            <p class="idea-desc">
              Calculates taxes for citizens and businesses based on income slabs, deductions,
              and applicable rules, keeping all records organized.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Dynamic Programming for Optimized Tax Computation
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Different combinations of deductions and slabs can be precomputed
              to minimize total tax legally. DP avoids recomputing subproblems for each user.
            </p>
            <pre class="idea-code"><code>// Simple DP pattern (concept: knapSack-style)
int max(int a, int b){ return a &gt; b ? a : b; }

int knapSack(int W, int wt[], int val[], int n) {
    if (n == 0 || W == 0) return 0;
    if (wt[n-1] &gt; W) return knapSack(W, wt, val, n-1);
    return max(val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),
               knapSack(W, wt, val, n-1));
}</code></pre>
          </div>

          <!-- 8. Banking Services -->
          <div class="idea-box">
            <h3>üè¶ Banking Services</h3>
            <p class="idea-desc">
              Manages customer accounts, transactions, balances, and fund transfers efficiently
              for all citizens and businesses in Bellasagaram.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Balanced Binary Search Tree (like AVL) for Account Lookup
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Searching customer IDs in a balanced BST gives <code>O(log n)</code>
              time insert/search, which is important when thousands of accounts are stored.
            </p>
            <pre class="idea-code"><code>// BST insert (simplified)
struct Node { int key; struct Node *left, *right; };

struct Node* newNode(int key){
    struct Node* n = malloc(sizeof(struct Node));
    n-&gt;key = key; n-&gt;left = n-&gt;right = NULL;
    return n;
}</code></pre>
          </div>

          <!-- 9. Hospital Network & Intelligent Bed Allocation -->
          <div class="idea-box">
            <h3>üè• Hospital Network &amp; Intelligent Bed Allocation System</h3>
            <p class="idea-desc">
              Connects all hospitals and assigns patients to the nearest hospital that has a
              free bed and the required specialization.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Dijkstra + Priority Queue for Nearest Free Hospital
            </p>
            <p class="idea-why">
              <strong>Why?</strong> Hospitals are nodes in a graph. Dijkstra finds the nearest hospital,
              and a priority queue of available beds ensures fast allocation when new requests come.
            </p>
            <pre class="idea-code"><code>// Distance init for Dijkstra
void initDist(int dist[], int n, int src) {
    for (int i = 0; i &lt; n; i++) dist[i] = 1e9;
    dist[src] = 0;
}</code></pre>
          </div>

          <!-- 10. Ambulance Allocation -->
          <div class="idea-box">
            <h3>üöë Ambulance Allocation Based on City Zones</h3>
            <p class="idea-desc">
              Assigns ambulances to emergency calls based on city zones, distance, and
              availability so that response time is minimum.
            </p>
            <p class="idea-algo">
              <strong>Algorithm:</strong> Greedy + Priority Queue (Closest Ambulance First)
            </p>
            <p class="idea-why">
              <strong>Why?</strong> For each emergency, choosing the closest available ambulance
              greedily gives near-optimal response time. A min-heap stores ambulances by distance.
            </p>
            <pre class="idea-code"><code>// Concept: store (distance, ambulanceId) in a min-heap
struct Amb {
    int dist;
    int id;
}; // heap of Amb can be used for nearest ambulance</code></pre>
          </div>

        </div> <!-- end ideas-grid-nam -->

      </div>
    </section>
  </main>

  <footer class="footer">
    <p>
      ¬© 2025 City Plan Bellasagaram ‚Äî Team 09, KLE Technological University, Hubballi.
      All rights reserved.
    </p>
  </footer>

  <script src="script.js"></script>
</body>
</html>
